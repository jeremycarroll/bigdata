/**

Copyright (C) SYSTAP, LLC 2006-2011.  All rights reserved.

Contact:
     SYSTAP, LLC
     4501 Tower Road
     Greensboro, NC 27410
     licenses@bigdata.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
/*
 * Created on Sep 4, 2011
 */

package com.bigdata.rdf.sparql.ast.eval;

import java.util.LinkedList;
import java.util.List;

import com.bigdata.bop.BOpUtility;
import com.bigdata.bop.Constant;
import com.bigdata.bop.IBindingSet;
import com.bigdata.bop.IConstant;
import com.bigdata.bop.IVariable;
import com.bigdata.bop.PipelineOp;
import com.bigdata.bop.Var;
import com.bigdata.bop.bindingSet.ListBindingSet;
import com.bigdata.bop.engine.QueryEngine;
import com.bigdata.bop.fed.QueryEngineFactory;
import com.bigdata.bop.join.NamedSolutionSetScanOp;
import com.bigdata.bop.solutions.ProjectionOp;
import com.bigdata.bop.solutions.SliceOp;
import com.bigdata.rdf.internal.impl.literal.XSDNumericIV;
import com.bigdata.rdf.model.BigdataLiteral;
import com.bigdata.rdf.model.BigdataURI;
import com.bigdata.rdf.model.BigdataValue;
import com.bigdata.rdf.model.BigdataValueFactory;
import com.bigdata.rdf.sparql.ast.ASTContainer;
import com.bigdata.rdf.sparql.ast.NamedSubqueryRoot;
import com.bigdata.rdf.sparql.ast.cache.ISparqlCache;
import com.bigdata.rdf.sparql.ast.cache.SparqlCacheFactory;
import com.bigdata.rdf.store.AbstractTripleStore;

/**
 * Data driven test suite for INCLUDE of named solution sets NOT generated by a
 * {@link NamedSubqueryRoot}.  This test suite is examines several details,
 * including the ability to locate and join with a pre-existing named solution
 * set, the ability to deliver the named solution set in order
 * 
 * @author <a href="mailto:thompsonbry@users.sourceforge.net">Bryan Thompson</a>
 * @version $Id: TestNamedSubQuery.java 6080 2012-03-07 18:38:55Z thompsonbry $
 */
public class TestInclude extends AbstractDataDrivenSPARQLTestCase {

    /**
     *
     */
    public TestInclude() {
    }

    /**
     * @param name
     */
    public TestInclude(String name) {
        super(name);
    }

    protected <T> IConstant<T> asConst(final T val) {

        return new Constant<T>(val);
        
    }
    
    /**
	 * This test populates a named solution set and then examines the ability to
	 * deliver that named solution set in the same order in which the data were
	 * stored. Normally, the named solution set would be created using
	 * <code>INSERT INTO SOLUTIONS</code>, but in this case we drop down a level
	 * and handle the creation of the named solution set in the test setup.
	 * 
	 * <pre>
	 * SELECT * WHERE { INCLUDE %solutionSet1 }
	 * </pre>
	 */
    public void test_include_01() throws Exception {
    	
        final TestHelper testHelper = new TestHelper(
        		"include_01",// name
        		"include_01.rq",// query URL
        		"include_01.trig",// data URL
        		"include_01.srx",// results URL
        		false,// lax cardinality
        		true  // check order(!)
        		);

        final AbstractTripleStore tripleStore = testHelper.getTripleStore();
        
        final BigdataValueFactory vf = tripleStore.getValueFactory();
        
		final QueryEngine queryEngine = QueryEngineFactory
				.getQueryController(tripleStore.getIndexManager());
		
		final ISparqlCache sparqlCache = SparqlCacheFactory
				.getSparqlCache(queryEngine);

		final String solutionSet = "%solutionSet1";
		
        final IVariable<?> x = Var.var("x");
        final IVariable<?> y = Var.var("y");
        final IVariable<?> z = Var.var("z");
        
		final XSDNumericIV<BigdataLiteral> one = new XSDNumericIV<BigdataLiteral>(
				1);
		one.setValue(vf.createLiteral(1));
		
		final XSDNumericIV<BigdataLiteral> two = new XSDNumericIV<BigdataLiteral>(
				2);
//		two.setValue(vf.createLiteral(2));
		
		final XSDNumericIV<BigdataLiteral> three = new XSDNumericIV<BigdataLiteral>(
				3);
//		three.setValue(vf.createLiteral(3));
		
		final XSDNumericIV<BigdataLiteral> four = new XSDNumericIV<BigdataLiteral>(
				4);
		four.setValue(vf.createLiteral(4));
		
		final XSDNumericIV<BigdataLiteral> five = new XSDNumericIV<BigdataLiteral>(
				5);
		five.setValue(vf.createLiteral(5));
		
        final List<IBindingSet> bsets = new LinkedList<IBindingSet>();
        {
            final IBindingSet bset = new ListBindingSet();
            bset.set(x, asConst(one));
            bset.set(y, asConst(two));
            bsets.add(bset);
        }
        {
            final IBindingSet bset = new ListBindingSet();
            bsets.add(bset);
        }
        {
            final IBindingSet bset = new ListBindingSet();
            bset.set(x, asConst(three));
            bset.set(y, asConst(four));
            bset.set(z, asConst(five));
            bsets.add(bset);
        }

        final IBindingSet[] bindingSets = bsets.toArray(new IBindingSet[]{});

		sparqlCache.putSolutions(solutionSet,
				BOpUtility.asIterator(bindingSets));

        final ASTContainer astContainer = testHelper.runTest();

        final PipelineOp queryPlan = astContainer.getQueryPlan();
        
        // top level should be the PROJECTION operator.
        assertTrue(queryPlan instanceof ProjectionOp);
        
        // sole argument should be the INCLUDE operator.
        final PipelineOp includeOp = (PipelineOp) queryPlan.get(0);
        
        // the INCLUDE should be evaluated using a solution set SCAN.
        assertTrue(includeOp instanceof NamedSolutionSetScanOp);
        
    }
    
    /**
	 * This test populates a named solution set and then examines the ability to
	 * deliver a SLICE of that named solution set in the same order in which the
	 * data were stored. Normally, the named solution set would be created using
	 * <code>INSERT INTO SOLUTIONS</code>, but in this case we drop down a level
	 * and handle the creation of the named solution set in the test setup.
	 * 
	 * <pre>
	 * SELECT ?x ?y WHERE { 
	 * 
	 *    # Turn off the join order optimizer.
	 *    hint:Query hint:optimizer "None" .
	 * 
	 *    # Run joins in the given order (INCLUDE is 2nd).
	 *    
	 *    # bind x => {Mike;Bryan}
	 *    ?x rdf:type foaf:Person .
	 *    
	 *    # join on (x) => {(x=Mike,y=2);(x=Bryan;y=4)} 
	 *    INCLUDE %solutionSet1 .
	 * 
	 * }
	 * </pre>
	 */
    public void test_include_02() throws Exception {

        final TestHelper testHelper = new TestHelper(
        		"include_02",// name
        		"include_02.rq",// query URL
        		"include_02.trig",// data URL
        		"include_02.srx",// results URL
        		false,// lax cardinality
        		true  // check order(!)
        		);

        final AbstractTripleStore tripleStore = testHelper.getTripleStore();
        
        final BigdataValueFactory vf = tripleStore.getValueFactory();
        
		final QueryEngine queryEngine = QueryEngineFactory
				.getQueryController(tripleStore.getIndexManager());
		
		final ISparqlCache sparqlCache = SparqlCacheFactory
				.getSparqlCache(queryEngine);

		final String solutionSet = "%solutionSet1";
		
        final IVariable<?> x = Var.var("x");
        final IVariable<?> y = Var.var("y");
        final IVariable<?> z = Var.var("z");
        
		final XSDNumericIV<BigdataLiteral> one = new XSDNumericIV<BigdataLiteral>(
				1);
		one.setValue(vf.createLiteral(1));
		
		final XSDNumericIV<BigdataLiteral> two = new XSDNumericIV<BigdataLiteral>(
				2);
//		two.setValue(vf.createLiteral(2));
		
		final XSDNumericIV<BigdataLiteral> three = new XSDNumericIV<BigdataLiteral>(
				3);
//		three.setValue(vf.createLiteral(3));
		
		final XSDNumericIV<BigdataLiteral> four = new XSDNumericIV<BigdataLiteral>(
				4);
		four.setValue(vf.createLiteral(4));
		
		final XSDNumericIV<BigdataLiteral> five = new XSDNumericIV<BigdataLiteral>(
				5);
		five.setValue(vf.createLiteral(5));
		
        final List<IBindingSet> bsets = new LinkedList<IBindingSet>();
        {
            final IBindingSet bset = new ListBindingSet();
            bset.set(x, asConst(one));
            bset.set(y, asConst(two));
            bsets.add(bset);
        }
        {
            final IBindingSet bset = new ListBindingSet();
            bsets.add(bset);
        }
        {
            final IBindingSet bset = new ListBindingSet();
            bset.set(x, asConst(three));
            bset.set(y, asConst(four));
            bset.set(z, asConst(five));
            bsets.add(bset);
        }

        final IBindingSet[] bindingSets = bsets.toArray(new IBindingSet[]{});

		sparqlCache.putSolutions(solutionSet,
				BOpUtility.asIterator(bindingSets));

        final ASTContainer astContainer = testHelper.runTest();

        final PipelineOp queryPlan = astContainer.getQueryPlan();
        
        // top level should be the SLICE operator.
        assertTrue(queryPlan instanceof SliceOp);

        // sole argument should be the PROJECTION operator.
        final PipelineOp projectionOp = (PipelineOp) queryPlan.get(0);

        assertTrue(projectionOp instanceof ProjectionOp);

        // sole argument should be the INCLUDE operator.
        final PipelineOp includeOp = (PipelineOp) projectionOp.get(0);
        
        // the INCLUDE should be evaluated using a solution set SCAN.
        assertTrue(includeOp instanceof NamedSolutionSetScanOp);
        
    }

    /**
	 * A unit test for an INCLUDE which is NOT the first JOIN in the WHERE
	 * clause. This condition is enforced by turning off the join order
	 * optimizer for this query.
	 * <p>
	 * Note: Since there is another JOIN in this query, there is no longer any
	 * order guarantee for the resulting solutions.
	 * 
	 * <pre>
	 * SELECT ?x ?z WHERE { INCLUDE %solutionSet1 }
	 * </pre>
	 */
    public void test_include_03() throws Exception {
    	
        final TestHelper testHelper = new TestHelper(
        		"include_03",// name
        		"include_03.rq",// query URL
        		"include_03.trig",// data URL
        		"include_03.srx",// results URL
        		false,// lax cardinality
        		false // check order
        		);

        final AbstractTripleStore tripleStore = testHelper.getTripleStore();
        
        final BigdataValueFactory vf = tripleStore.getValueFactory();
        
		final QueryEngine queryEngine = QueryEngineFactory
				.getQueryController(tripleStore.getIndexManager());
		
		final ISparqlCache sparqlCache = SparqlCacheFactory
				.getSparqlCache(queryEngine);

		final String solutionSet = "%solutionSet1";
		
        final IVariable<?> x = Var.var("x");
        final IVariable<?> y = Var.var("y");

        // Resolve terms pre-loaded into the kb.
        final BigdataURI Mike = vf.createURI("http://www.bigdata.com/Mike"); 
        final BigdataURI Bryan = vf.createURI("http://www.bigdata.com/Bryan");
        final BigdataURI DC = vf.createURI("http://www.bigdata.com/DC");
		{
			tripleStore.addTerms(new BigdataValue[] { Mike, Bryan, DC });
			assertNotNull(Mike.getIV());
			assertNotNull(Bryan.getIV());
			assertNotNull(DC.getIV());
		}

		final XSDNumericIV<BigdataLiteral> one = new XSDNumericIV<BigdataLiteral>(
				1);
		one.setValue(vf.createLiteral(1));
		
		final XSDNumericIV<BigdataLiteral> two = new XSDNumericIV<BigdataLiteral>(
				2);
		two.setValue(vf.createLiteral(2));
		
//		final XSDNumericIV<BigdataLiteral> three = new XSDNumericIV<BigdataLiteral>(
//				3);
//		three.setValue(vf.createLiteral(3));
		
		final XSDNumericIV<BigdataLiteral> four = new XSDNumericIV<BigdataLiteral>(
				4);
		four.setValue(vf.createLiteral(4));
		
//		final XSDNumericIV<BigdataLiteral> five = new XSDNumericIV<BigdataLiteral>(
//				5);
//		five.setValue(vf.createLiteral(5));
		
        final List<IBindingSet> bsets = new LinkedList<IBindingSet>();
        {
            final IBindingSet bset = new ListBindingSet();
            bset.set(x, asConst(Mike.getIV()));
            bset.set(y, asConst(two));
            bsets.add(bset);
        }
        {
            final IBindingSet bset = new ListBindingSet();
            bset.set(x, asConst(Bryan.getIV()));
            bset.set(y, asConst(four));
            bsets.add(bset);
        }
        {
            final IBindingSet bset = new ListBindingSet();
            bset.set(x, asConst(DC.getIV()));
            bset.set(y, asConst(one));
            bsets.add(bset);
        }

        final IBindingSet[] bindingSets = bsets.toArray(new IBindingSet[]{});

		sparqlCache.putSolutions(solutionSet,
				BOpUtility.asIterator(bindingSets));

        final ASTContainer astContainer = testHelper.runTest();

//        final PipelineOp queryPlan = astContainer.getQueryPlan();
//        
//        // top level should be the SLICE operator.
//        assertTrue(queryPlan instanceof SliceOp);
//
//        // sole argument should be the PROJECTION operator.
//        final PipelineOp projectionOp = (PipelineOp) queryPlan.get(0);
//
//        assertTrue(projectionOp instanceof ProjectionOp);
//
//        // sole argument should be the INCLUDE operator.
//        final PipelineOp includeOp = (PipelineOp) projectionOp.get(0);
//        
//        // the INCLUDE should be evaluated using a solution set SCAN.
//        assertTrue(includeOp instanceof NamedSolutionSetScanOp);

    }
    
}
