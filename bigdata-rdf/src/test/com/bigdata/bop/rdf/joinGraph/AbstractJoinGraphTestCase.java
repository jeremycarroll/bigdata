/**

Copyright (C) SYSTAP, LLC 2006-2011.  All rights reserved.

Contact:
     SYSTAP, LLC
     4501 Tower Road
     Greensboro, NC 27410
     licenses@bigdata.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
/*
 * Created on Jan 18, 2011
 */

package com.bigdata.bop.rdf.joinGraph;

import java.io.File;
import java.io.FilenameFilter;
import java.util.Arrays;
import java.util.Properties;

import junit.framework.TestCase2;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;

import com.bigdata.bop.BOpContextBase;
import com.bigdata.bop.BOpIdFactory;
import com.bigdata.bop.BOpUtility;
import com.bigdata.bop.IBindingSet;
import com.bigdata.bop.IConstraint;
import com.bigdata.bop.IPredicate;
import com.bigdata.bop.IVariable;
import com.bigdata.bop.PipelineOp;
import com.bigdata.bop.ap.SampleIndex.SampleType;
import com.bigdata.bop.engine.BOpStats;
import com.bigdata.bop.engine.IRunningQuery;
import com.bigdata.bop.engine.QueryEngine;
import com.bigdata.bop.engine.QueryLog;
import com.bigdata.bop.fed.QueryEngineFactory;
import com.bigdata.bop.joinGraph.IRangeCountFactory;
import com.bigdata.bop.joinGraph.PartitionedJoinGroup;
import com.bigdata.bop.joinGraph.fast.DefaultEvaluationPlan2;
import com.bigdata.bop.joinGraph.rto.JGraph;
import com.bigdata.bop.joinGraph.rto.Path;
import com.bigdata.journal.Journal;
import com.bigdata.rdf.store.AbstractTripleStore;
import com.bigdata.relation.accesspath.IAsynchronousIterator;
import com.bigdata.relation.rule.IRule;
import com.bigdata.relation.rule.Rule;

/**
 * @author <a href="mailto:thompsonbry@users.sourceforge.net">Bryan Thompson</a>
 * @version $Id$
 */
abstract public class AbstractJoinGraphTestCase extends TestCase2 {

    /**
     * 
     */
    public AbstractJoinGraphTestCase() {
    }

    /**
     * @param name
     */
    public AbstractJoinGraphTestCase(String name) {
        super(name);
    }
    
    private Journal jnl;
    
    protected QueryEngine queryEngine; 

    /** The initial sampling limit. */
    static private final int limit = 100;

	/**
	 * The #of edges considered for the initial paths.
	 * 
	 * FIXME We need to consider all of the low cardinality vertices, e.g., BSBM
	 * Q5 has 3 such vertices. Also, we should not consider vertices when
	 * looking for the initial edges which are relatively unconstrained (e.g.,
	 * 1-bound). This could be handled by sampling the top-N vertices in reverse
	 * rank order of their cardinality and any with a cardinality LT 10x the
	 * initial sample limit.
	 */
    static private final int nedges = 2;

    static private final SampleType sampleType = SampleType.EVEN;
    
    /**
     * When true, do a warm up run of the plan generated by the static query
     * optimizer.
     */
    static private final boolean warmUp = false;
    
    /**
     * The #of times to run each query. Use N GT ONE (1) if you want to converge
     * onto the hot query performance.
     */
    static private final int ntrials = 10;

    /**
     * When <code>true</code> evaluates the query using the given join ordering.
     */
    static private final boolean runGivenOrder = false;

    /**
     * When <code>true</code> runs the dynamic query optimizer and then evaluates
     * the generated query plan.
     */
    static private final boolean runRuntimeQueryOptimizer = true;
    
    /**
     * When <code>true</code> runs the static query optimizer and then evaluates
     * the generated query plan.
     */
    static private final boolean runStaticQueryOptimizer = true;

    /**
     * Open/create the journal, setting the {@link #database} and
     * {@link #namespace} as side-effects.
     * 
     * @param properties
     *            The properties.
     *            
     * @return The journal.
     * 
     * @throws Exception
     */
    abstract protected Journal getJournal(final Properties properties)
            throws Exception;

    /**
     * The namespace of the {@link AbstractTripleStore} instance to be used by
     * the test.
     */
    abstract protected String getNamespace();
    
    /**
     * 
     */
    protected void setUp() throws Exception {

        super.setUp();
        
        jnl = getJournal(getProperties());
        
        queryEngine = QueryEngineFactory
                .getQueryController(jnl/* indexManager */);

//        database = (AbstractTripleStore) jnl.getResourceLocator().locate(
//                namespace, jnl.getLastCommitTime());
//
//        if (database == null)
//            throw new RuntimeException("Not found: " + namespace);

    }

    protected void tearDown() throws Exception {

//        if (database != null) {
//            database = null;
//        }

        if (queryEngine != null) {
            queryEngine.shutdownNow();
            queryEngine = null;
        }

        if (jnl != null) {
            jnl.close();
            jnl = null;
        }

        super.tearDown();

    }

    protected QueryEngine getQueryEngine() {
        
        return queryEngine;
        
    }
    
    protected AbstractTripleStore getDatabase(final String namespace) {

        final AbstractTripleStore database = (AbstractTripleStore) jnl
                .getResourceLocator()
                .locate(namespace, jnl.getLastCommitTime());

        if (database == null)
            throw new RuntimeException("Not found: " + namespace);

        return database;

    }

    /**
     * 
     * @param preds
     *            The join graph.
     * @param constraints
     *            The constraints on the join graph.
     * @return The ordering on the join graph predicates reported by the runtime
     *         optimizer.
     * 
     * @throws Exception
     * 
     * @todo To actually test anything this needs to compare the results (or at
     *       least the #of result). We could also test for known good join
     *       orders as generated by the runtime optimizer, but that requires a
     *       known data set (e.g., U1 or U50) and non-random sampling.
     * 
     * @todo This is currently providing a "hot run" comparison by a series of
     *       trials. This means that the IO costs are effectively being wiped
     *       away, assuming that the file system cache is larger than the data
     *       set. The other way to compare performance is a cold cache / cold
     *       JVM run using the known solutions produced by the runtime versus
     *       static query optimizers.
     */
	protected IPredicate<?>[] doTest(final boolean distinct,
			final IVariable<?>[] selected, final IPredicate<?>[] preds,
			final IConstraint[] constraints) throws Exception {

        if (warmUp)
			runQuery("Warmup", queryEngine, distinct, selected,
					runStaticQueryOptimizer(getQueryEngine(), preds),
					constraints);

        /*
         * Run the runtime query optimizer once (its cost is not counted
         * thereafter).
         */
        final IPredicate<?>[] runtimePredOrder = runRuntimeQueryOptimizer(
                getQueryEngine(), limit, nedges, sampleType, preds, constraints);

        long totalGivenTime = 0;
        long totalRuntimeTime = 0;
        long totalStaticTime = 0;
        
		long givenSolutions = 0;
		long runtimeSolutions = 0;
		long staticSolutions = 0;
		
        for (int i = 0; i < ntrials; i++) {

            final String RUNTIME = getName() + " : runtime["+i+"] :";

            final String STATIC =  getName() + " : static ["+i+"] :";

            final String GIVEN =  getName() + " : given  ["+i+"] :";

            if (runGivenOrder) {

            	final long begin = System.currentTimeMillis();
				final BOpStats stats = runQuery(GIVEN, queryEngine, distinct,
						selected, preds, constraints);
				final long nout = stats.unitsOut.get();
				if (i == 0)
					givenSolutions = nout;
				else if (givenSolutions != nout) {
					fail("#solutions inconsistent for given plan: "
							+ givenSolutions + " versus " + nout);
				}
                totalGivenTime += System.currentTimeMillis() - begin;

            }

			if (runStaticQueryOptimizer) {

				final long begin = System.currentTimeMillis();
				final BOpStats stats = runQuery(STATIC, queryEngine, distinct,
						selected, runStaticQueryOptimizer(getQueryEngine(),
								preds), constraints);
				final long nout = stats.unitsOut.get();
				if (i == 0)
					staticSolutions = nout;
				else if (staticSolutions != nout) {
					fail("#solutions inconsistent for static plan: "
							+ staticSolutions + " versus " + nout);
				}
				totalStaticTime += System.currentTimeMillis() - begin;
			}

			if (runRuntimeQueryOptimizer) {

				/*
				 * Run the runtime query optimizer each time (its overhead is
				 * factored into the running comparison of the two query
				 * optimizers).
				 */
				// final IPredicate[] runtimePredOrder =
				// runRuntimeQueryOptimizer(new JGraph(
				// preds));

				// Evaluate the query using the selected join order.
				final long begin = System.currentTimeMillis();
				final BOpStats stats = runQuery(RUNTIME, queryEngine, distinct,
						selected, runtimePredOrder, constraints);
				final long nout = stats.unitsOut.get();
				if (i == 0)
					runtimeSolutions = nout;
				else if (runtimeSolutions != nout) {
					fail("#solutions inconsistent for runtime plan: "
							+ runtimeSolutions + " versus " + nout);
				}
                totalRuntimeTime += System.currentTimeMillis() - begin;

            }

        }

        if (runStaticQueryOptimizer && runRuntimeQueryOptimizer) {
            System.err.println(getName() + " : Total times" + //
                    ": static=" + totalStaticTime + //
                    ", runtime=" + totalRuntimeTime + //
                    ", delta(static-runtime)=" + (totalStaticTime - totalRuntimeTime));
        }
		if (staticSolutions != runtimeSolutions) {
			fail("#solutions inconsistent: static=" + staticSolutions
					+ ", runtime=" + runtimeSolutions);
		}

        return runtimePredOrder;
        
    }
    
    /**
     * Apply the runtime query optimizer.
     * <p>
     * Note: This temporarily raises the {@link QueryLog} log level during
     * sampling to make the log files cleaner (this can not be done for a
     * deployed system since the logger level is global and there are concurrent
     * query mixes).
     * 
     * @return The predicates in order as recommended by the runtime query
     *         optimizer.
     * 
     * @throws Exception
     */
    static protected IPredicate<?>[] runRuntimeQueryOptimizer(
            final QueryEngine queryEngine, final int limit, final int nedges,
            final SampleType sampleType,
            final IPredicate<?>[] preds, IConstraint[] constraints)
            throws Exception {

        final Logger tmp = Logger.getLogger(QueryLog.class);
        final Level oldLevel = tmp.getEffectiveLevel();
        tmp.setLevel(Level.WARN);

        try {

            final JGraph g = new JGraph(preds, constraints, sampleType);
            
            final Path p = g.runtimeOptimizer(queryEngine, limit, nedges);

//          System.err.println(getName() + " : runtime optimizer join order "
//                  + Arrays.toString(Path.getVertexIds(p.edges)));

            return p.getPredicates();

        } finally {

            tmp.setLevel(oldLevel);

        }

    }

    /**
     * Apply the static query optimizer.
     * 
     * @return The predicates in order as recommended by the static query
     *         optimizer.
     */
    static protected IPredicate<?>[] runStaticQueryOptimizer(
            final QueryEngine queryEngine, final IPredicate<?>[] preds) {

        final BOpContextBase context = new BOpContextBase(queryEngine);

        final IRule rule = new Rule("tmp", null/* head */, preds, null/* constraints */);

        final DefaultEvaluationPlan2 plan = new DefaultEvaluationPlan2(
                new IRangeCountFactory() {

                    public long rangeCount(final IPredicate pred) {
                        return context.getRelation(pred).getAccessPath(pred)
                                .rangeCount(false);
                    }

                }, rule);

        // evaluation plan order.
        final int[] order = plan.getOrder();

        final int[] ids = new int[order.length];
        
        final IPredicate<?>[] out = new IPredicate[order.length];

        for (int i = 0; i < order.length; i++) {

            out[i] = preds[order[i]];
            
            ids[i] = out[i].getId();

        }
        
//      System.err.println(getName() + " :  static optimizer join order "
//              + Arrays.toString(ids));
        
        return out;
        
    }

	/**
	 * Run a query joining a set of {@link IPredicate}s in the given join order.
	 * 
	 * @return The stats for the last operator in the pipeline.
	 */
	protected static BOpStats runQuery(final String msg,
			final QueryEngine queryEngine, final boolean distinct,
			final IVariable<?>[] selected, final IPredicate<?>[] predOrder,
			final IConstraint[] constraints) throws Exception {

        if (log.isInfoEnabled())
            log.info("Running " + msg);

        final BOpIdFactory idFactory = new BOpIdFactory();

        final int[] ids = new int[predOrder.length];

        for (int i = 0; i < ids.length; i++) {

            final IPredicate<?> p = predOrder[i];

            idFactory.reserve(p.getId());

            ids[i] = p.getId();

        }

        final PipelineOp queryOp = PartitionedJoinGroup.getQuery(idFactory,
                distinct, selected, predOrder, constraints);

        System.out.println(BOpUtility.toString(queryOp));
        
        // run the query, counting results and chunks.
        long nout = 0;
        long nchunks = 0;
        final IRunningQuery q = queryEngine.eval(queryOp);
        try {
            // drain the query results.
            final IAsynchronousIterator<IBindingSet[]> itr = q.iterator();
            try {
                while (itr.hasNext()) {
                    final IBindingSet[] chunk = itr.next();
                    nout += chunk.length;
                    nchunks++;
                }
            } finally {
                itr.close();
            }
        } finally {
        	// ensure terminated.
            q.cancel(true/* mayInterruptIfRunning */);
        }

        // Check the Future for the query.
		if (q.getCause() != null) {
			// Wrap Throwable from abnormal termination.
        	throw new RuntimeException(q.getCause());
        }

        // show the results.
        final BOpStats stats = q.getStats().get(queryOp.getId());

        System.err.println(msg + " : ids=" + Arrays.toString(ids)
                + ", elapsed=" + q.getElapsed() + ", nout=" + nout
                + ", nchunks=" + nchunks + ", stats=" + stats);

//        if(false) {
//
//        	final StringBuilder sb = new StringBuilder();
//			
//        	QueryLog.log(true/* tableHeader */, q, sb);
//			
//        	System.err.println(sb);
//        	
//		}

        return stats;

    }

    /**
     * Reads files matching the filter from the directory and return
     * an array containing their path names.
     * 
     * @param dir
     *            The directory.
     * @param filter
     *            The filter.
     */
    static protected String[] readFiles(final File dir,
            final FilenameFilter filter) {

        assertTrue("No such file or directory: " + dir, dir.exists());

        assertTrue("Not a directory: " + dir, dir.isDirectory());

        final File[] files = dir.listFiles(filter);

        assertNotNull("Could not read directory: " + dir, files);

        final String[] resources = new String[files.length];

        for (int i = 0; i < files.length; i++) {

            resources[i] = files[i].toString();

        }

        return resources;

    }

}
