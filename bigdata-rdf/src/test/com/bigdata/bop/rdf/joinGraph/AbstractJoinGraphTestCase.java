/**

Copyright (C) SYSTAP, LLC 2006-2011.  All rights reserved.

Contact:
     SYSTAP, LLC
     4501 Tower Road
     Greensboro, NC 27410
     licenses@bigdata.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
/*
 * Created on Jan 18, 2011
 */

package com.bigdata.bop.rdf.joinGraph;

import java.io.File;
import java.io.FilenameFilter;
import java.util.Arrays;
import java.util.Properties;

import junit.framework.TestCase2;

import org.apache.log4j.Level;
import org.apache.log4j.Logger;

import com.bigdata.bop.BOpContextBase;
import com.bigdata.bop.BOpIdFactory;
import com.bigdata.bop.IBindingSet;
import com.bigdata.bop.IConstraint;
import com.bigdata.bop.IPredicate;
import com.bigdata.bop.PipelineOp;
import com.bigdata.bop.controller.PartitionedJoinGroup;
import com.bigdata.bop.controller.JoinGraph.JGraph;
import com.bigdata.bop.controller.JoinGraph.Path;
import com.bigdata.bop.engine.BOpStats;
import com.bigdata.bop.engine.IRunningQuery;
import com.bigdata.bop.engine.QueryEngine;
import com.bigdata.bop.engine.QueryLog;
import com.bigdata.bop.fed.QueryEngineFactory;
import com.bigdata.journal.Journal;
import com.bigdata.rdf.store.AbstractTripleStore;
import com.bigdata.relation.accesspath.IAsynchronousIterator;
import com.bigdata.relation.rule.IRule;
import com.bigdata.relation.rule.Rule;
import com.bigdata.relation.rule.eval.DefaultEvaluationPlan2;
import com.bigdata.relation.rule.eval.IRangeCountFactory;

/**
 * @author <a href="mailto:thompsonbry@users.sourceforge.net">Bryan Thompson</a>
 * @version $Id$
 */
abstract public class AbstractJoinGraphTestCase extends TestCase2 {

    /**
     * 
     */
    public AbstractJoinGraphTestCase() {
    }

    /**
     * @param name
     */
    public AbstractJoinGraphTestCase(String name) {
        super(name);
    }
    
    private Journal jnl;
    
//    protected AbstractTripleStore database;

//    private String namespace;

    private QueryEngine queryEngine; 

    /** The initial sampling limit. */
    static private final int limit = 100;
    
    /** The #of edges considered for the initial paths. */
    static private final int nedges = 2;

    /**
     * When true, do a warm up run of the plan generated by the static query
     * optimizer.
     */
    static private final boolean warmUp = false;
    
    /**
     * The #of times to run each query. Use N GT ONE (1) if you want to converge
     * onto the hot query performance.
     */
    static private final int ntrials = 1;

    /**
     * When <code>true</code> evaluates the query using the given join ordering.
     */
    static private final boolean runGivenOrder = false;

    /**
     * When <code>true</code> runs the dynamic query optimizer and then evaluates
     * the generated query plan.
     */
    static private final boolean runRuntimeQueryOptimizer = true;
    
    /**
     * When <code>true</code> runs the static query optimizer and then evaluates
     * the generated query plan.
     */
    static private final boolean runStaticQueryOptimizer = true;

    /**
     * Open/create the journal, setting the {@link #database} and
     * {@link #namespace} as side-effects.
     * 
     * @param properties
     *            The properties.
     *            
     * @return The journal.
     * 
     * @throws Exception
     */
    abstract protected Journal getJournal(final Properties properties)
            throws Exception;

    /**
     * The namespace of the {@link AbstractTripleStore} instance to be used by
     * the test.
     */
    abstract protected String getNamespace();
    
    /**
     * 
     */
    protected void setUp() throws Exception {

        super.setUp();
        
        jnl = getJournal(getProperties());
        
        queryEngine = QueryEngineFactory
                .getQueryController(jnl/* indexManager */);

//        database = (AbstractTripleStore) jnl.getResourceLocator().locate(
//                namespace, jnl.getLastCommitTime());
//
//        if (database == null)
//            throw new RuntimeException("Not found: " + namespace);

    }

    protected void tearDown() throws Exception {

//        if (database != null) {
//            database = null;
//        }

        if (queryEngine != null) {
            queryEngine.shutdownNow();
            queryEngine = null;
        }

        if (jnl != null) {
            jnl.close();
            jnl = null;
        }

        super.tearDown();

    }

    protected QueryEngine getQueryEngine() {
        
        return queryEngine;
        
    }
    
    protected AbstractTripleStore getDatabase(final String namespace) {

        final AbstractTripleStore database = (AbstractTripleStore) jnl
                .getResourceLocator()
                .locate(namespace, jnl.getLastCommitTime());

        if (database == null)
            throw new RuntimeException("Not found: " + namespace);

        return database;

    }
    
    /**
     * 
     * @param preds
     * @throws Exception
     * 
     * @todo To actually test anything this needs to compare the results (or at
     *       least the #of result). We could also test for known good join
     *       orders as generated by the runtime optimizer, but that requires a
     *       known data set (e.g., U1 or U50) and non-random sampling.
     * 
     * @todo This is currently providing a "hot run" comparison by a series of
     *       trials. This means that the IO costs are effectively being wiped
     *       away, assuming that the file system cache is larger than the data
     *       set. The other way to compare performance is a cold cache / cold
     *       JVM run using the known solutions produced by the runtime versus
     *       static query optimizers.
     */
    protected void doTest(final IPredicate<?>[] preds,
            final IConstraint[] constraints) throws Exception {

        if (warmUp)
            runQuery("Warmup", queryEngine, runStaticQueryOptimizer(
                    getQueryEngine(), preds), constraints);

        /*
         * Run the runtime query optimizer once (its cost is not counted
         * thereafter).
         */
        final IPredicate<?>[] runtimePredOrder = runRuntimeQueryOptimizer(
                getQueryEngine(), limit, nedges, preds, constraints);

        long totalRuntimeTime = 0;
        long totalStaticTime = 0;
        
        for (int i = 0; i < ntrials; i++) {

            final String RUNTIME = getName() + " : runtime["+i+"] :";

            final String STATIC =  getName() + " : static ["+i+"] :";

            final String GIVEN =  getName() + " : given  ["+i+"] :";

            if (runGivenOrder) {

                runQuery(GIVEN, queryEngine, preds, constraints);
                
            }

            if (runStaticQueryOptimizer) {

                totalStaticTime += runQuery(STATIC, queryEngine,
                        runStaticQueryOptimizer(getQueryEngine(), preds),
                        constraints);

            }

            if (runRuntimeQueryOptimizer) {

                /*
                 * Run the runtime query optimizer each time (its overhead is
                 * factored into the running comparison of the two query
                 * optimizers).
                 */
//              final IPredicate[] runtimePredOrder = runRuntimeQueryOptimizer(new JGraph(
//                      preds));

                // Evaluate the query using the selected join order.
                totalRuntimeTime += runQuery(RUNTIME, queryEngine,
                        runtimePredOrder, constraints);

            }

        }

        if (runStaticQueryOptimizer && runRuntimeQueryOptimizer) {
            System.err.println(getName() + " : Total times" + //
                    ": static=" + totalStaticTime + //
                    ", runtime=" + totalRuntimeTime + //
                    ", delta(static-runtime)=" + (totalStaticTime - totalRuntimeTime));
        }

    }
    
    /**
     * Apply the runtime query optimizer.
     * <p>
     * Note: This temporarily raises the {@link QueryLog} log level during
     * sampling to make the log files cleaner (this can not be done for a
     * deployed system since the logger level is global and there are concurrent
     * query mixes).
     * 
     * @return The predicates in order as recommended by the runtime query
     *         optimizer.
     * 
     * @throws Exception
     */
    static protected IPredicate<?>[] runRuntimeQueryOptimizer(
            final QueryEngine queryEngine, final int limit, final int nedges,
            final IPredicate<?>[] preds, IConstraint[] constraints)
            throws Exception {

        final Logger tmp = Logger.getLogger(QueryLog.class);
        final Level oldLevel = tmp.getEffectiveLevel();
        tmp.setLevel(Level.WARN);

        try {

            final JGraph g = new JGraph(preds, constraints);
            
            final Path p = g.runtimeOptimizer(queryEngine, limit, nedges);

//          System.err.println(getName() + " : runtime optimizer join order "
//                  + Arrays.toString(Path.getVertexIds(p.edges)));

            return p.getPredicates();

        } finally {

            tmp.setLevel(oldLevel);

        }

    }

    /**
     * Apply the static query optimizer.
     * 
     * @return The predicates in order as recommended by the static query
     *         optimizer.
     */
    static protected IPredicate<?>[] runStaticQueryOptimizer(
            final QueryEngine queryEngine, final IPredicate<?>[] preds) {

        final BOpContextBase context = new BOpContextBase(queryEngine);

        final IRule rule = new Rule("tmp", null/* head */, preds, null/* constraints */);

        final DefaultEvaluationPlan2 plan = new DefaultEvaluationPlan2(
                new IRangeCountFactory() {

                    public long rangeCount(final IPredicate pred) {
                        return context.getRelation(pred).getAccessPath(pred)
                                .rangeCount(false);
                    }

                }, rule);

        // evaluation plan order.
        final int[] order = plan.getOrder();

        final int[] ids = new int[order.length];
        
        final IPredicate<?>[] out = new IPredicate[order.length];

        for (int i = 0; i < order.length; i++) {

            out[i] = preds[order[i]];
            
            ids[i] = out[i].getId();

        }
        
//      System.err.println(getName() + " :  static optimizer join order "
//              + Arrays.toString(ids));
        
        return out;
        
    }

    /**
     * Run a query joining a set of {@link IPredicate}s in the given join order.
     * 
     * @return The elapsed query time (ms).
     */
    private static long runQuery(final String msg,
            final QueryEngine queryEngine, final IPredicate<?>[] predOrder,
            final IConstraint[] constraints) throws Exception {

        if (log.isInfoEnabled())
            log.info("Running " + msg);

        final BOpIdFactory idFactory = new BOpIdFactory();

        final int[] ids = new int[predOrder.length];

        for (int i = 0; i < ids.length; i++) {

            final IPredicate<?> p = predOrder[i];

            idFactory.reserve(p.getId());

            ids[i] = p.getId();

        }

        final PipelineOp queryOp = PartitionedJoinGroup.getQuery(idFactory,
                predOrder, constraints);

        // submit query to runtime optimizer.
        final IRunningQuery q = queryEngine.eval(queryOp);

        try {

            // drain the query results.
            long nout = 0;
            long nchunks = 0;
            final IAsynchronousIterator<IBindingSet[]> itr = q.iterator();
            try {
                while (itr.hasNext()) {
                    final IBindingSet[] chunk = itr.next();
                    nout += chunk.length;
                    nchunks++;
                }
            } finally {
                itr.close();
            }

            // check the Future for the query.
            q.get();

            // show the results.
            final BOpStats stats = q.getStats().get(queryOp.getId());

            System.err.println(msg + " : ids=" + Arrays.toString(ids)
                    + ", elapsed=" + q.getElapsed() + ", nout=" + nout
                    + ", nchunks=" + nchunks + ", stats=" + stats);

            return q.getElapsed();

        } finally {

            q.cancel(true/* mayInterruptIfRunning */);
            
        }

    }

    /**
     * Reads files matching the filter from the directory and return
     * an array containing their path names.
     * 
     * @param dir
     *            The directory.
     * @param filter
     *            The filter.
     */
    static protected String[] readFiles(final File dir,
            final FilenameFilter filter) {

        assertTrue("No such file or directory: " + dir, dir.exists());

        assertTrue("Not a directory: " + dir, dir.isDirectory());

        final File[] files = dir.listFiles(filter);

        assertNotNull("Could not read directory: " + dir, files);

        final String[] resources = new String[files.length];

        for (int i = 0; i < files.length; i++) {

            resources[i] = files[i].toString();

        }

        return resources;

    }

}
