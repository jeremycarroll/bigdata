/**

Copyright (C) SYSTAP, LLC 2006-2011.  All rights reserved.

Contact:
     SYSTAP, LLC
     4501 Tower Road
     Greensboro, NC 27410
     licenses@bigdata.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
/*
 * Created on Aug 30, 2011
 */

package com.bigdata.rdf.sparql.ast;

import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Set;

import com.bigdata.bop.BOp;
import com.bigdata.bop.BOpUtility;
import com.bigdata.bop.IBindingSet;
import com.bigdata.bop.IVariable;

import cutthecrap.utils.striterators.Striterator;

/**
 * Class identifies the join variables for each instance in which a named
 * subquery solution set is incorporated into the query plan. 
 * 
 * @see NamedSubqueryRoot
 * @see NamedSubqueryInclude
 * 
 * @author <a href="mailto:thompsonbry@users.sourceforge.net">Bryan Thompson</a>
 * @version $Id$
 */
public class ASTNamedSubqueryOptimizer implements IASTOptimizer {

    /**
     * 
     * @throws RuntimeException
     *             if there is an {@link NamedSubqueryInclude} for a named
     *             solution set which is not generated by the query.
     * @throws RuntimeException
     *             if there is an {@link NamedSubqueryRoot} for a named solution
     *             set which is not consumed by the query.
     * @throws RuntimeException
     *             if there is more than one {@link NamedSubqueryRoot} for a
     *             given named solution set.
     */
    @Override
    public IQueryNode optimize(AST2BOpContext context, IQueryNode queryNode,
            DatasetNode dataset, IBindingSet[] bindingSet) {
        
        final QueryRoot queryRoot = (QueryRoot) queryNode;
        
        final NamedSubqueriesNode namedSubqueries = queryRoot.getNamedSubqueries();
        
        if (namedSubqueries == null || namedSubqueries.isEmpty()) {

            // NOP.
            return queryRoot;
            
        }

        // The set of all INCLUDEs in the query.
        final NamedSubqueryInclude[] allIncludes = findAllIncludes(queryRoot);

        // Verify that a named subquery exists for each INCLUDE.
        for (NamedSubqueryInclude anInclude : allIncludes) {

            final String namedSet = anInclude.getName();

            if (namedSet == null || namedSet.trim().length() == 0)
                throw new RuntimeException(
                        "Missing or illegal name for include.");
            
            boolean found = false;

            for (NamedSubqueryRoot aNamedSubquery : namedSubqueries) {

                if (aNamedSubquery.getName().equals(namedSet)) {
                    found = true;
                    break;
                }

            }
            
            if (!found)
                throw new RuntimeException(
                        "No subquery produces that solution set: " + namedSet);

        }

        /*
         * Verify that each named subquery is consumed by at least one include
         * somewhere in the WHERE clause of the query.
         */

        // The set of all named solution sets produced by this query.
        final Set<String> namedSets = new LinkedHashSet<String>();
        
        for (NamedSubqueryRoot aNamedSubquery : namedSubqueries) {

            final String namedSet = aNamedSubquery.getName();

            if (!namedSets.add(namedSet)) {

                throw new RuntimeException("NamedSet declared more than once: "
                        + namedSet);

            }
            
            if (namedSet == null || namedSet.trim().length() == 0)
                throw new RuntimeException(
                        "Missing or illegal name for named subquery.");

            final List<NamedSubqueryInclude> includes = new LinkedList<NamedSubqueryInclude>();

            for (NamedSubqueryInclude anInclude : allIncludes) {

                if (namedSet.equals(anInclude.getName())) {

                    includes.add(anInclude);

                }

            }

            if (includes.isEmpty()) {
                throw new RuntimeException(
                        "Named subquery results are not used by this query: "
                                + namedSet);
            }

            /*
             * Figure out the join variables for each place in the query where
             * the named result set is included and rewrite the include operator
             * (or just annotate it) to specify the join variables for that
             * include.
             * 
             * FIXME This assumes that we will always use all variables
             * projected by the subquery as the join variables. We need to
             * figure out which variables "must" be bound and then use just
             * those variables for the hash join.
             * 
             * FIXME If there are no such variables then we have to do a nested
             * loop join without an index! Personally, I think that such cases
             * should be rejected since performance will suck.
             */

            final IVariable[] projected = aNamedSubquery.getProjection()
                    .getProjectionVars();

            final VarNode[] proj = new VarNode[projected.length];

            for (int i = 0; i < projected.length; i++) {

                proj[i] = new VarNode(projected[i].getName());

            }

            for (NamedSubqueryInclude anInclude : includes) {

                anInclude.setJoinVars(proj);

            }

        }

        return queryRoot;

    }

    /**
     * Return all {@link NamedSubqueryInclude}s which appear in the WHERE clause
     * of the main query.
     */
    private NamedSubqueryInclude[] findAllIncludes(final QueryRoot queryRoot) {

        final Striterator itr = new Striterator(
                BOpUtility.postOrderIterator((BOp) queryRoot.getWhereClause()));

        itr.addTypeFilter(NamedSubqueryInclude.class);

        final List<NamedSubqueryInclude> list = new LinkedList<NamedSubqueryInclude>();

        while (itr.hasNext()) {

            list.add((NamedSubqueryInclude) itr.next());

        }

        return list.toArray(new NamedSubqueryInclude[] {});

    }

}
