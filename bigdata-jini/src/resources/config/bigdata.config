import net.jini.jeri.BasicILFactory;
import net.jini.jeri.BasicJeriExporter;
import net.jini.jeri.tcp.TcpServerEndpoint;

import net.jini.discovery.LookupDiscovery;
import net.jini.core.discovery.LookupLocator;
import net.jini.core.entry.Entry;
import net.jini.lookup.entry.Name;
import net.jini.lookup.entry.Comment;
import net.jini.lookup.entry.Address;
import net.jini.lookup.entry.Location;
import net.jini.lookup.entry.ServiceInfo;

import java.io.File;

import com.bigdata.util.NV;
import com.bigdata.journal.BufferMode;
import com.bigdata.jini.lookup.entry.*;
import com.bigdata.service.IBigdataClient;
import com.bigdata.service.jini.*;
import com.bigdata.jini.start.config.*;

import org.apache.zookeeper.ZooDefs;
import org.apache.zookeeper.data.ACL;
import org.apache.zookeeper.data.Id;

/*
 * This is a sample configuration file for a bigdata federation using
 * jini and zookeeper.
 * 
 * Note: This file uses the jini configuration mechanism.  The syntax
 * is a subset of Java.  The properties for each component are grouped
 * within the namespace for that component.
 *
 * See the net.jini.config.ConfigurationFile javadoc for more
 * information.
 *
 * @todo should generate a JiniClient.config file as an output. You
 * can use this file, but the contents can be pruned down quite a bit
 * for a standard client.  Or we could store the config in zookeeper
 * and then you just need the federation name and list of host:port
 * pairs for zookeeper.
 */

/*
 * A namespace use for static entries referenced elsewhere in this
 * ConfigurationFile.
 */
bigdata {

    /**
     * The name for this federation.
     *
     * Note: This is used to form the [zroot] (root node in zookeeper
     * for the federation) and the [serviceDir] (path in the file
     * system for persistent state for the federation).
     *
     * Note: If you will be running more than one federation, then you
     * MUST use unicast discovery and specify the federation name in
     * the [groups].
     */
    static private fedname = "E:\\lubmFed";

    // The default root for all persistent state.
    static private serviceDir = new File(fedname);

    /*
     * Example cluster configuration.
     *
     * Data services are load balanced.  Index partitions will be
     * moved around as necessary to ensure hosts running data
     * service(s) are neither under nor over utilized.  Data services
     * can be very resource intensive processes.  They heavily buffer
     * both reads and writes, and they use RAM to do so.  They also
     * support high concurrency and can use up to one thread per index
     * partition.  How many cores they will consume is very much a
     * function of the application.
     *
     * Zookeeper services use a quorum model.  Always allocate an odd
     * number.  3 gives you one failure.  5 gives you two failures.
     * Zookeeper will sync the disk almost continuously while it is
     * running.  It really deserves its own local disk.  Zookeeper
     * also runs in memory.  Since all operations are serialized, if
     * it starts swapping then peformance will drop through the floor.
     *
     * Jini uses a peer model.  Each service registers with each
     * registrar that it discovers.  Each client listeners to each
     * registrar that it discovers.  The default jini core services
     * installation runs entirely in memory (no disk operations, at
     * least not for service registration). A second instance of the
     * jini core services provides a safety net.  If you are using
     * multicast then you can always add another instance.
     */

    static private lbs = "localhost";
    static private txs = "localhost";
    static private mds = "localhost";
    // jini server(s).
    static private jini1 = "localhost";
//     static private jini2 = "localhost";
//     static private jini = new String[]{jini1,jini2};
    // 2 class servers
//     static private cls1 = "192.168.6.21";
//     static private cls2 = "192.168.6.23"; // doubled up with zoo2
//     static private cls = new String[]{cls1,cls2};
    // 3 zookeeper machines (one instance per).
    static private zoo1 = "localhost";
//     static private zoo2 = "192.168.6.23";
//     static private zoo3 = "192.168.6.24";
    static private zoo = new String[] {zoo1};
    // data service machines (could be more than one instance per).
    static private ds1 = "localhost";
//     static private ds2 = "192.168.6.26";
//     static private ds3 = "192.168.6.27";
//     static private ds4 = "192.168.6.28";
//     static private ds5 = "192.168.6.29";
//     static private ds6 = "192.168.6.30";
//     static private ds7 = "192.168.6.31";
//     static private ds8 = "192.168.6.32";
//     static private ds9 = "192.168.6.33";
//     static private ds10 = "192.168.6.34";
//     static private ds11 = "192.168.6.35";
    //static private ds = new String[]{ds1,ds2,ds3,ds4,ds5,ds6,ds7,ds8,ds9,ds10,ds11};
    static private ds = new String[]{ds1};
    static private dataServiceCount = 2;
	static private maxDataServicePerHost = 2;

    /**
     * A String[] whose values are the group(s) to be used for discovery
     * (no default). Note that multicast discovery is always used if
     * LookupDiscovery.ALL_GROUPS (a <code>null</code>) is specified.
     */

    // one federation, multicast discovery.
    static private groups = LookupDiscovery.ALL_GROUPS;

    // multiple federations, MUST use unicast discovery.
    //groups = new String[]{bigdata.fedname};

    /**
     * One or more unicast URIs of the form <code>jini://host/</code>
     * or <code>jini://host:port/</code> (no default).
     *
     * This MAY be an empty array if you want to use multicast
     * discovery <strong>and</strong> you have specified the groups as
     * LookupDiscovery.ALL_GROUPS (a <code>null</code>).
     */
    static private locators = new LookupLocator[] {

	// runs jini on the localhost using unicast locators.
	//new LookupLocator("jini://localhost/")
	
	// runs jini on two hosts using unicast locators.
	//new LookupLocator("jini://"+jini1),
	//new LookupLocator("jini://"+jini2),

    };

    /**
     * The policy file that will be used to start services.
     *
     * Note: The default policy is completely open.
     */
    private static policy = "policy.all";
    
    /**
     * Where jini is installed.
     */
    private static JINI_HOME = new File("C:\\Program Files\\jini2_1");

}

/*
 * Service configuration defaults.  These can also be specified on a
 * per service-type basis.  When the property is an array type, the
 * value here is concatenated with the optional array value on the per
 * service-type configuration.  Otherwise it is used iff no value is
 * specified for the service-type configuration.
 */
com.bigdata.jini.start.config.ServiceConfiguration {

    /* 
     * Default java command line arguments that will be used for all
     * java-based services
     *
     * Note: [-Dcom.sun.jini.jeri.tcp.useNIO=true] enables NIO.
     */
    defaultJavaArgs = new String[]{
	"-server",
	"-ea",
	"-Dcom.sun.jini.jeri.tcp.useNIO=true",
	"-Djava.security.policy="+bigdata.policy
    };

    // Optional classpath components.
    //classpath=new String[]{};

    /* A handy idiom that may be used to add things to the classpath.

    classpath = (String[])ServiceConfiguration.concat
	( new String[]{
	    "../bigdata-lubm/bigdata-lubm.jar",
	    "../bigdata-rdf/lib/slf4j-api-1.4.3.jar",
	    "../bigdata-rdf/lib/slf4j-log4j12-1.4.3.jar",
	    "../bigdata-rdf/lib/openrdf-sesame-2.2-onejar.jar"
	},
	  ServiceConfiguration.getClassPath()
	  );
*/

    /* Default path for service instances and their persistent
     * data. This may be overriden on a per service-type basis. 
     *
     * Note: For logical services that support failover, the concrete
     * service directory is assigned dynamically when a physical
     * service instance is created.
     */
    serviceDir = bigdata.serviceDir;
 
    /* The bigdata services default logging configuration (a URI!)
     *
     * You need log all the services.  You can use SocketAppender
     * and SimpleSocketServer or struggle with  syslog or write the
     * logs into well known files.  If files, they really need to be on
     * a shared volume so that you can see all of the output.
     *
     * @see http://wiki.apache.org/logging-log4j/syslog
     * @see http://threebit.net/mail-archive/tomcat-users/msg00219.html
     * @see http://www.linuxjournal.com/article/5476
     */
    log4j="file:../bigdata-lubm/src/resources/logging/log4j.properties";

    /*
     * Set up some default properties values that will be inherited
     * (copy by value) by all clients and services started using this
     * configuration file.
     */
    properties = new NV[] {

    /* 
     * Each JiniClient (and hence all bigdata services) can run an
     * httpd that will expose performance counters for the service and
     * the host on which it is running.  This property specifies the
     * port for that httpd service.  Valid values are port number,
     * zero (0) for a random open port, MINUS ONE (-1) to disable the
     * httpd service.
     */
    new NV(IBigdataClient.Options.HTTPD_PORT, "-1"),

    /*
     * Option to disable collection of performance counters for the
     * host on which the client or service is running.
     *
     * Note: The load balancer relies on this information!
     */
    new NV(IBigdataClient.Options.COLLECT_PLATFORM_STATISTICS,"false"),

    /* Option to disable collection of performance counters on the
     * queues used internally by the client or service.
     *
     * Note: The load balancer relies on this information!
     */
    new NV(IBigdataClient.Options.COLLECT_QUEUE_STATISTICS,"false"),

    };

}

/**
 * Class server.
 *
 * The class server exposes downloadable code to services and clients.
 * It does this using an httpd service which runs on the specified
 * port.  Clients and servers need to know the URL(s) at which they
 * can connect to the class server in advance, so you have to specify
 * which host(s) will run the class server.
 *
 * That information gets put into the
 */
com.sun.jini.tool.ClassServer {

    classpath = new String[] {

	bigdata.JINI_HOME+File.separator+"lib"+File.separator+"classserver.jar"

    };

    /**
     * Port used for the httpd.
     */
    port = 8082;

}

/**
 * Jini service configuration.
 *
 * WARNING: Starting the jini services browser requires a GUI.  If you
 * are running from a terminal without a GUI then you MUST edit the
 * JINI_HOME/installverify/support/startAll.config file and comment
 * out the "Browser" component.  Unfortunately, you have to install it
 * with a GUI in the first place.
 *
 * Note: You can probably comment out several of the other components
 * as well.  We are using reggie (the service registrar), and the
 * classserver might be a depenency for reggie, but I don't believe
 * that anything else is being used.
 */
jini {

    /**
     * Where jini was installed.
     */
    serviceDir = bigdata.JINI_HOME;

    /**
     * The #of instances to run.
     *
     * Note: A jini service instance may be started on a host if it is
     * declared in [locators].  If locators is empty, then you are
     * using multicast discovery.  In this case an instance may be
     * started on any host, unless [constraints] are imposed.  In any
     * case, no more than [serviceCount] jini services will be started
     * at any given time.  This is checked against the #of discovered
     * instances.
     */
    serviceCount = 1;

}

/**
 * Zookeeper server configuration.
 */
org.apache.zookeeper.server.quorum.QuorumPeerMain {

    /* Directory for zookeeper's persistent state.  The [id] will be
     * appended as another path component automatically to keep
     * instances separate.
     */
    dataDir = new File(bigdata.serviceDir,"zookeeper");

    /* Optional directory for the zookeeper log files.  The [id] will
     * be appended as another path component automatically to keep
     * instances separate.
     * 
     * Note: A dedicated log device is highly recommended!
     */
    //dataLogDir=new File("/var/zookeeper-log");

    // required.
    clientPort=2181;

    tickTime=2000;

    initLimit=5;

    syncLimit=2;

    /* A comma delimited list of the known zookeeper servers together
     * with their assigned "myid": {myid=host:port(:port)}+
     *
     * Note: You SHOULD specify the full list of servers that are
     * available to the federation. An instance of zookeeper will be
     * started automatically on each host running ServicesManager that
     * is present in the [servers] list IF no instance is found
     * running on that host at the specified [clientPort].
     * 
     * Note: zookeeper interprets NO entries as the localhost with
     * default peer and leader ports. This will work as long as the
     * localhost is already running zookeeper.  However, zookeeper
     * WILL NOT automatically start zookeeper if you do not specify
     * the [servers] property.  You can also explicitly specify
     * "localhost" as the hostname, but that only works for a single
     * machine.
     */
    // standalone
    servers="1=localhost:2888:3888";
    // ensemble
    /* @todo use ctor[] for zoo server entry?
    servers =   "1="+bigdata.zoo1+":2888:3888"
            + ",2="+bigdata.zoo2+":2888:3888"
	    + ",3="+bigdata.zoo3+":2888:3888"
	    ;
    */

    // This is all you need to run zookeeper.
    classpath = new String[] {
    	"../bigdata-jini/lib/apache/zookeeper-3.0.1.jar",
		"../bigdata/lib/apache/log4j-1.2.15.jar"
    };

    /* Optional command line arguments for the JVM used to execute
     * zookeeper.
     *
     * Note: swapping for zookeeper is especially bad since the
     * operations are serialized, so if anything hits then disk then
     * all operations in the queue will have that latency as well.
     */
    //args=new String[]{"-Xmx2G"};

    // zookeeper server logging configuration (value is a URI!)
    log4j="file:src/resources/logging/log4j.properties";

}

/*
 * Zookeeper client configuration.
 */
org.apache.zookeeper.ZooKeeper {

    /* Root znode for the federation instance. */
    zroot = "/"+bigdata.fedname;

    /* A comma separated list of host:port pairs, where the port is
     * the CLIENT port for the zookeeper server instance.
     */
    servers = "localhost:2181";

    /* Session timeout (optional, but heavy load can cause disconnects with
     * the default timeout).
     */
    sessionTimeout = 20000;

    /* 
     * ACLs for the federation zroot.
     *
     * Note: zookeeper ACLs are not transmitted over secure channels
     * and are placed into plain text Configuration files by the
     * ServicesManagerServer.
     */
    acl = new ACL[] {

	new ACL(ZooDefs.Perms.ALL, new Id("world", "anyone"))

    };

}

/*
 * Jini client configuration
 */
com.bigdata.service.jini.JiniClient {

    /* Default Entry[] for jini services.  Also used by the
     * ServicesManagerService as is.
     *
     * Note: A Name attribute will be added automatically using the
     * service type and the znode of the service instance.  That Name
     * will be canonical.  It is best if additional service names are
     * NOT specified as that might confuse somethings :-)
     *
     * Note: A Hostname attribute will be added dynamically.
     */
    entries = new Entry[] {
	// Purely informative.
	new Comment(bigdata.fedname),
    };

    groups = bigdata.groups;

    locators = bigdata.locators;

    // optional JiniClient properties.
    //properties = new NV[] {};

}

/**
 * Options for the bigdata services manager.
 */
com.bigdata.jini.start.ServicesManagerServer {

    /*
     * This object is used to export the service proxy.  The choice
     * here effects the protocol that will be used for communications
     * between the clients and the service.
     */
    exporter = new BasicJeriExporter(TcpServerEndpoint.getInstance(0),
                                     new BasicILFactory()); 

    /*                                          
     * The data directory and the file on which the serviceID will be
     * written.
     *
     * Note: These properties MUST be specified explicitly for the
     * ServicesManager since it uses this as its Configuration file.
     * For other services, it generates the Configuration file and
     * will generate this property as well.
     */

    serviceDir = new File(bigdata.serviceDir,"ServicesManager");

    serviceIdFile = new File(serviceDir,"service.id");
    
    /* The services that will be started.  For each service, there
     * must be a corresponding component defined within this
     * configuration file.  For each "ManagedServiceConfiguration", an
     * entry will be made in zookeeper and logical and physical
     * service instances will be managed automatically.  For unmanaged
     * services, such as jini and zookeeper itself, instances will be
     * started iff necessary by the services manager when it starts
     * up.
     */
    services = new String[] {
	
      	"jini",
 	"org.apache.zookeeper.server.quorum.QuorumPeerMain",
  	"com.bigdata.service.jini.TransactionServer",
    	"com.bigdata.service.jini.MetadataServer",
    	"com.bigdata.service.jini.DataServer",
    	"com.bigdata.service.jini.LoadBalancerServer"
	
    };

    /*
     * Additional properties passed through to the JiniClient or the
     * service.
     *
     * Note: I am leaving the OS statistics collection enabled for the
     * services manager and plan to run an instance on each host.
     * That will let me see the load on all hosts where I otherwise
     * would not have reports available for the zookeeper only
     * machines.
     */
    properties = new NV[]{

	/* Don't collect statistics from the OS since there is no load
	 * balancing for the ServicesManager itself.
	 */
	new NV(IBigdataClient.Options.COLLECT_PLATFORM_STATISTICS, "false"),

	// Don't sample the various queues
	// 
	// Note: Disabled for single-machine runs since performance counters.
	// don't matter with only one host.
	// 
	// @TODO Enable this for any multiple machine runs!
	//
	new NV(IBigdataClient.Options.COLLECT_QUEUE_STATISTICS,"false"),

	// Don't run the httpd service (data are still reported to the
	// load balancer).
	new NV(IBigdataClient.Options.HTTPD_PORT, "-1"),

    };

    /* Note: I am deliberately running this on every host to get OS
     * performance counters aggregated within the load balancer, even
     * for hosts that will not run bigdata services, such as the
     * zookeeper machines.
     */
    constraints = new IServiceConstraint[] {

    	//new HostAllowConstraint(sms)

    };

}

/**
 * Initial configuration for new instances of the transaction server.
 */
com.bigdata.service.jini.TransactionServer {

    constraints = new IServiceConstraint[] {

	new JiniRunningConstraint(),
	new ZookeeperRunningConstraint(),

	new HostAllowConstraint(bigdata.txs)

    };

	properties = new NV[] {
	
	/* The #of milliseconds that the database will retain history no
	 * longer required to support the earliest active transaction.
	 *
	 * A value of ZERO means that only the last commit point will
	 * be retained.  The larger the value the more history will be
	 * retained.  You can use a really big number if you never want
	 * to release history and you have lots of disk space :-)
	 *
	 * Note: The most recent committed state of the database is
	 * NEVER released.
	 */
	new NV(TransactionServer.Options.MIN_RELEASE_AGE, "0"),

	};

}

com.bigdata.service.jini.MetadataServer {

    constraints = new IServiceConstraint[] {

	new JiniRunningConstraint(),
	new ZookeeperRunningConstraint(),
	new TXRunningConstraint(),

	new HostAllowConstraint(bigdata.mds),

    };

}

com.bigdata.service.jini.DataServer {

    serviceCount = bigdata.dataServiceCount;

    args = new String[]{
	//"-Xmx4G", // grant lots of memory.
	//"-XX:-UseGCOverheadLimit", // @todo might not be required.
    };

    // restrict where the data services can run.
    constraints = new IServiceConstraint[] {

	new JiniRunningConstraint(),
	new ZookeeperRunningConstraint(),
	new TXRunningConstraint(),

	new HostAllowConstraint(bigdata.ds),

	new MaxDataServicesPerHostConstraint(bigdata.maxDataServicePerHost),

    };

    /*
     * Note: the [dataDir] will be filled in when a new service
     * instance is created based on the [servicesDir], so don't set it
     * here yourself.
     */
    params = new NV[]{

	//new NV(DataServer.Options.BUFFER_MODE,com.bigdata.journal.BufferMode.Disk.toString()),

	/* Override the initial and maximum extent so that they are
	 * more suited to large data sets (200M).  Overflow will be
	 * triggered as the size of the journal approaches the maximum
	 * extent.
	 */

	new NV(DataServer.Options.INITIAL_EXTENT, "209715200"),
	new NV(DataServer.Options.MAXIMUM_EXTENT, "209715200"),

    };

}

com.bigdata.service.jini.LoadBalancerServer {

    constraints = new IServiceConstraint[] {

	new JiniRunningConstraint(),
	new ZookeeperRunningConstraint(),

	new HostAllowConstraint(bigdata.lbs)

    };

    /*
     * Override some properties.
     */
    properties = new NV[] {

    /* 
     * Each JiniClient (and hence all bigdata services) can run an
     * httpd that will expose performance counters for the service and
     * the host on which it is running.  This property specifies the
     * port for that httpd service.  Valid values are port number,
     * zero (0) for a random open port, MINUS ONE (-1) to disable the
     * httpd service.
     *
     * Note: The load balancer httpd normally uses a known port so
     * that it is easy to find.  This is where you will find all of
     * the performance counters aggregated for the entire federation,
     * including their history.
     */
    new NV(IBigdataClient.Options.HTTPD_PORT, "8080"),

    /*
     * Note: The load balancer SHOULD NOT collect platform statistics
     * itself since that interfers with its ability to aggregate
     * statistics about the host on which it is running.  Instead it
     * should rely on the presence of at least one other service
     * running on the same host to report those statistics to the load
     * balancer.
     */
    new NV(IBigdataClient.Options.COLLECT_PLATFORM_STATISTICS,"false"),
		
    /* 
     * The directory where the aggregated statistics will be logged.
     *
     * You only need to specify this if you want to put the files into
     * a well known location.
     *
     * @todo verify that an override here works.
     */
    //new NV(LoadBalancerServer.Options.LOG_DIR,"/opt2/var/log/bigdata")

    };

}

/**
 * Options for a utility to send a sighup() message to all discovered
 * services managers.
 */
com.bigdata.service.jini.BroadcastSighup {

	// push the service configuration to zookeeper.
	pushConfig = false;
	
	// restart any services not currently running.
	restartServices = true;

	// time in milliseconds to wait for service discovery	
	discoveryDelay = 5000;

}
