import net.jini.jeri.BasicILFactory;
import net.jini.jeri.BasicJeriExporter;
import net.jini.jeri.tcp.TcpServerEndpoint;

import net.jini.discovery.LookupDiscovery;
import net.jini.core.discovery.LookupLocator;
import net.jini.core.entry.Entry;
import net.jini.lookup.entry.Name;
import net.jini.lookup.entry.Comment;
import net.jini.lookup.entry.Address;
import net.jini.lookup.entry.Location;
import net.jini.lookup.entry.ServiceInfo;
import net.jini.core.lookup.ServiceTemplate;

import java.io.File;
import java.net.InetSocketAddress;
import java.util.UUID;

import com.bigdata.util.NV;
import com.bigdata.journal.Options;
import com.bigdata.journal.BufferMode;
import com.bigdata.jini.lookup.entry.*;
import com.bigdata.service.IBigdataClient;
import com.bigdata.service.jini.*;
import com.bigdata.service.jini.lookup.DataServiceFilter;
import com.bigdata.service.jini.master.ServicesTemplate;
import com.bigdata.jini.start.config.*;
import com.bigdata.jini.util.ConfigMath;

// imports for various options.
import com.bigdata.btree.IndexMetadata;
import com.bigdata.btree.keys.KeyBuilder;
import com.bigdata.rdf.sail.BigdataSail;
import com.bigdata.rdf.spo.SPORelation;
import com.bigdata.rdf.spo.SPOKeyOrder;
import com.bigdata.rdf.lexicon.LexiconRelation;
import com.bigdata.rdf.lexicon.LexiconKeyOrder;
import com.bigdata.rawstore.Bytes;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeUnit.*;

/*
 * This is a sample configuration file for a highly available Journal. A
 * version of this file must be available to each HAJournalServer in the
 * pipeline.  The pipeline depends on the stable assignment of ServiceID
 * to HAJournalServers.  A unique ServiceID must be explicitly assigned to 
 * each HAJournalServer in its configuration entry.  The ordered list of 
 * those ServiceIDs is shared by all services and defines the write 
 * replication pipeline. The first entry in the write replication pipeline
 * is the leader (aka master).  You can use UUID.randomUUID() or GenUUID
 * to create UUIDs.
 *
 * Note: The ServiceUUID Entry MUST be different for each file.  It assigns
 * a ServiceID to the service!
 */

/*
 * Globals.
 */
bigdata {

   private static fedname = "benchmark";
   
   // write replication pipeline port.
   private static port = 81;
   
   // The ServiceID for *this* service.
   private static serviceId = UUID.fromString("3c7e7639-78bf-452c-9ca9-2960caec17dc");
   
   // The write replication pipeline.
   private static pipeline = new UUID[] {
      UUID.fromString("3c7e7639-78bf-452c-9ca9-2960caec17dc"),
      UUID.fromString("a6120400-d63d-40d6-8ddb-3c283d0d5e3c"),
      //UUID.fromString("d609dcf7-860c-40f1-bd2f-eebdce20556c"),
   };
   
   // service directory.
   private static serviceDir = new File(fedname,""+serviceId);
   
   // journal data directory.
   private static dataDir = serviceDir;

   // one federation, multicast discovery.
   static private groups = LookupDiscovery.ALL_GROUPS;

   // unicast discovery or multiple setups, MUST specify groups.
   //static private groups = new String[]{bigdata.fedname};

    /**
     * One or more unicast URIs of the form <code>jini://host/</code>
     * or <code>jini://host:port/</code> (no default).
     *
     * This MAY be an empty array if you want to use multicast
     * discovery <strong>and</strong> you have specified the groups as
     * LookupDiscovery.ALL_GROUPS (a <code>null</code>).
     */
    static private locators = new LookupLocator[] {

      // runs jini on the localhost using unicast locators.
      //new LookupLocator("jini://localhost/")
   
      // runs jini on one or more hosts using unicast locators.
      //new LookupLocator("jini://"+jini1),
      //new LookupLocator("jini://"+jini2),

    };

}

/*
 * You should not have to edit below this line.
 */

/*
 * Server configuration options.
 */
com.bigdata.journal.jini.ha.HAJournalServer {

   serviceDir = bigdata.serviceDir;

   groups = bigdata.groups;
   
   locators = bigdata.locators;

   entries = new Entry[] {
      
      new ServiceUUID(bigdata.serviceId),
      
   };

   // Where the service will expose its write replication listener.
   writePipelineAddr = new InetSocketAddress("localhost",bigdata.port);

   /*
   writePipelineAddr = new InetSocketAddress(//
                    InetAddress.getByName(//
                            NicUtil.getIpAddress("default.nic", "default",
                                    false// loopbackOk
                            )), //
                    bigdata.port
            );
   */   

   pipelineUUIDs = bigdata.pipeline;

}

/*
 * Journal configuration options.
 */
com.bigdata.journal.jini.ha.HAJournal {

   // The default KB namespace
   static private namespace = "kb";

   properties = new NV[] {
   
      new NV(Options.FILE,
         ConfigMath.getAbsolutePath(new File(bigdata.dataDir,"bigdata-ha.jnl"))),
   
      new NV(Options.BUFFER_MODE,""+BufferMode.DiskRW),

      new NV(IndexMetadata.Options.WRITE_RETENTION_QUEUE_CAPACITY,"4000"),

      new NV(IndexMetadata.Options.BTREE_BRANCHING_FACTOR,"128"),

   };

}
