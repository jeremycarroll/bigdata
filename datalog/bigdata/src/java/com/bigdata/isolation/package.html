<html>
<head>
<title>B+Tree Isolation Support</title>
</head>
<body>

<p>
A B+-Tree designed to support transactional isolation.  This builds on
the features of the base B+-Tree package, which already supports
copy-on-write semantics, and on the Journal package, which already
supports a policy in which valid data are never overwritten.  Indices
that support transactional isolation maintain both version counters
and deletion markers.  The version counter is used to detect
write-write conflicts.  The delete marker is used to mark keys that
have been deleted until a full compacting merge can be performed.
</p>

<p>
The basic design for isolation requires that reads are performed
against a historical committed state of the store (the ground state,
which is typically the last committed state of the store at the time
that the transaction begins) while writes are isolated (they are not
visible outside of the transaction). The basic mechanism for isolation
is an {@link com.bigdata.btree.IIndex} that reads through to a read-only btree loaded
from a historical metadata record while writes go into the isolated
btree (the write set of the transaction). The isolated btree is used
by the transaction and never by another transaction.
</p>

<p>
In order to commit, the transaction must validate the write set on the
isolated btree against the then current committed state of the
btree. If there have been no intervening commits then validation is a
NOP since the read-only btree that the isolated btree reads through to
is the current committed state. If there have been intervening
commits, then validation may identify write-write conflicts
(read-write conflicts are obviated by the basic design). A write-write
conflict exists when a concurrent transaction wrote a record for the
same key as the transaction that is being validated and has already
committed (conflicts are not visible until a writer has committed).
</p>

<p>
Once a transaction has validated it is merged down onto the globally
visible state of the btree. This process consists simply of applying
the changes to the globally visible btree, including both inserts of
key-value pairs and removal of keys that were deleted during the
transaction.
</p>

<p>
If a transaction is reading from or writing on more than one btree,
then it must validate the write set for each btree during its
validation stage and merge down the write set for each btree during
its merge stage. Once this merge process is complete, the btree is
flushed to the backing store which results in a new checkpoint
record. The mapping from the btree name to checkpoint record is
then updated on the backing store. Finally, an atomic commit is then
performed on the backing store. At this point the transaction has
successfully completed.
</p>

</body>
</html>