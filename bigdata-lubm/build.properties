# ant build properties.

# the base directory
lubm.dir=.
# the bigdata base directory
bigdata.dir=..

# Where the generated files will be written.
build.dir=ant-build
# Where to find the pre-built bigdata classes.
bigdata.build.dir=${bigdata.dir}/ant-build

bigdata.install.lib.dir=${bigdata.dir}/

##
# javac options
##

# debug=on|off
javac.debug=on
# debuglevel=lines,vars,source (or any combination thereof).
javac.debuglevel=lines,vars,source
javac.verbose=off
#javac.target=1.6
#javac.source=1.6
javac.encoding=Cp1252

# lubm properties.
#
# Note: By default, the files will wind up in ./ant-build/bin

# The port at which the NanoSparqlServer will respond (if started).
lubm.nanoServerPort=80

# The maximum size of the java heap for the LUBM test runs.
lubm.maxMem=4g

# The data set size (U50, U1000, etc.)
lubm.univ=50

# The namespace of the KB instance (multiple KBs can be in the same database).
lubm.namespace=LUBM_U${lubm.univ}

#lubm.baseDir=d:/bigdata-perf-analysis/lubm/lubm_${lubm.univ}
lubm.baseDir=/nas/data/lubm/U${lubm.univ}

## Where to put the XML results files.
#bsbm.resultsDir=${bsbm.baseDir}/..

# The ontology file.
lubm.ontologyFile=${lubm.dir}/src/resources/config/univ-bench.owl

# The directory in which the generator writes its data.
lubm.dataDir=${lubm.baseDir}/data

# Generate ntriples.
lubm.outputType=nt

# Specify "GZip", "Zip", or "None"
lubm.compressType=GZip

# Which mode to use for the Journal. (DiskRW or DiskWORM)
#journalMode=RW
journalMode=WORM

## The name of the directory containing the generated RDF data without the filename extension.
#lubm.outputFile=${lubm.baseDir}

# The name of the file used to configure the BSBM journal.
lubm.journalPropertyFile=${journalMode}Store.properties

# The name of the file used for the BSBM journal.
#bsbm.journalFile=${bsbm.baseDir}/bigdata-bsbm.rw
#bsbm.journalFile=${bsbm.baseDir}/bigdata-bsbm.worm
#bsbm.journalFile=${bsbm.baseDir}/bigdata-bsbm.jnl
# Note: This is on the large volume.
lubm.journalFile=/data/lubm/U${lubm.univ}/bigdata-lubm.${journalMode}.jnl

# The database to test.
lubm.configFile=${lubm.dir}/src/resources/config/config.kb.sparql

# The queries to run.
lubm.queryFile=${lubm.dir}/src/resources/config/config.query.sparql

#
# Query parameters.
#

#
# Profiler parameters.
#

# No profiler.
profilerAgent=
# linux-64
#profilerAgent=-agentpath:/usr/java/yjp-9.0.3/bin/linux-x86-64/libyjpagent.so
# Windows
#profilerAgent="-agentpath:C:/Program Files/YourKit Java Profiler 9.0.1/bin/win32/yjpagent.dll"

# No profiler.
profilerAgentOptions=
# all profiling initially disabled.
#profilerAgentOptions=-agentlib:yjpagent=disableexceptiontelemetry,disablestacktelemetry

profiler=${profilerAgent} ${profilerAgentOptions}

# Configure GC for higher throughput.  Together these options request
# parallel old generation collection using N threads.  The application
# will be paused when this occurs, but GC will be faster.  Hence
# throughput will be higher.  However, be sure to use JDK 6u10+ (6676016
# : ParallelOldGC leaks memory).
#
# http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6676016
#
# Note: By degault, the server jvm will optimize for throughput and can have
# high variation in throughput due to long GC pauses for larger heaps. You can
# use the CMS-I GC mode to minimize latency at the expense of some throughput.
gcopts=
#gcopts=-verbose:gc
gcopts=-XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode
#gcopts=-XX:+UseParallelOldGC -XX:ParallelGCThreads=4

# Generates detailed logging on the JVM GC behavior.  The service will
# start in the configured service directory, so the log file will be in
# that directory as well.  The service directory is typically on local
# disk, so that is where you need to look for this file.
gcdebug=
#gcdebug=-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:jvm_gc.log

# The record cache (empty for the default cache).
cache=
#cache=-Dcom.bigdata.LRUNexus.class=com.bigdata.cache.BCHMGlobalLRU2 -Dcom.bigdata.LRUNexus.threadLocalBuffers=true
#cache=-Dcom.bigdata.LRUNexus.class=com.bigdata.cache.BCHMGlobalLRU -Dcom.bigdata.LRUNexus.accessPolicy=LIRS -Dcom.bigdata.LRUNexus.limitingCapacity=2000000
#-Dcom.bigdata.LRUNexus.class=com.bigdata.cache.StoreAndAddressLRUCache
#-Dcom.bigdata.LRUNexus.class=com.bigdata.cache.HardReferenceGlobalLRURecycler

# all jvm args for query.
# <jvmarg value="-server" />
# <jvmarg value="-Xmx${bsbm.maxMem}" />
# <jvmarg value="-Dlog4j.configuration=log4j.properties" />
# <jvmarg value="-Dcom.bigdata.journal.AbstractJournal.file=${bsbm.journalFile}" />
queryJvmArgs=-server -Xmx${lubm.maxMem} ${gcopts} ${gcdebug} ${profiler} ${cache} -Dlog4j.configuration=log4j.properties
