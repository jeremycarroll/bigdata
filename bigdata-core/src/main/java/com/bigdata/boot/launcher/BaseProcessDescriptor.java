/*

Copyright (C) SYSTAP, LLC 2006-2008.  All rights reserved.

Contact:
     SYSTAP, LLC
     4501 Tower Road
     Greensboro, NC 27410
     licenses@bigdata.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*/
package com.bigdata.boot.launcher;

import com.bigdata.boot.ProcessState;
import com.bigdata.boot.MessageTransport;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.TimerTask;
import java.util.logging.Logger;
import java.util.logging.Level;

abstract class BaseProcessDescriptor implements ProcessDescriptor {

    /** Reference to the main launcher object. */
    protected final LauncherMain launcher;

    /** Unique identifier for the associated process. */
    protected final String tag;

    /** Logger for output generated by this process. */
    protected final Logger logger;

    /** Configuration properties for this process */
    protected ProcessConfiguration config;

    /** Current state of the associated process. */
    private ProcessState state = ProcessState.STOPPED;

    /** The Process object for the associated process. */
    private Process proc;

    /** Instance of the StdoutLoggingThread object for the process. */
    private Thread stdoutMonThread;

    /** Instance of the ProcessDeathMonitorThread for the process. */
    private Thread deathMonThread;

    /**
     * TimerTask that times out and kills processes that have been in the
     * STOPPING state beyond a given time limit.
     */
    private TimerTask stoppingTimerTask;

    /**
     * Reference to the connected message transport to the process. This
     * will only be valid after the process has identified itself to
     * the launcher.
     */
    private MessageTransport associatedConnection;


    public BaseProcessDescriptor(LauncherMain         launcher,
                                 ProcessConfiguration config)
    {
        this.launcher = launcher;
        this.tag = config.tag;
        this.logger = Logger.getLogger("com.bigdata.boot.launcher." + tag);
        this.config = config;
    }

    public String getTag() {
        return tag;
    }

    public synchronized ProcessState getState() {
        return state;
    }

    public synchronized void start() {
        if((state != ProcessState.STOPPED) && (state != ProcessState.FAILED)) {
            return;
        }

        if( launcher.isShuttingDown() ) return;

        changeState(ProcessState.STARTING);

        try {
            this.proc = spawnProcess();
        } catch(Exception e) {
            logger.log(Level.SEVERE, "Failed to start process", e);
            changeState(ProcessState.FAILED);
            return;
        }

        if( !config.performHandshake ) {
            // There is no startup handshake so just say it's running.
            // If it didn't start right then it'll be detected soon enough.
            changeState(ProcessState.RUNNING);
        } else {
            // Leave the state as "STARTING" until the process signals
            // that it's running
        }

        // Start a thread to log stdout & stderr
        stdoutMonThread = new StdoutLoggingThread(tag);
        stdoutMonThread.start();

        // Start a thread to wait for the process' death
        deathMonThread = new ProcessDeathMonitorThread(tag);
        deathMonThread.start();
    }

    public synchronized void stop(boolean abrupt) {
        boolean stopFlag = false;
        if((state == ProcessState.STARTING)||(state == ProcessState.RUNNING)) {
            changeState(ProcessState.STOPPING);
            stopFlag = true;
        } else if((state == ProcessState.STOPPING) && abrupt) {
            stopFlag = true;
        }

        if(stopFlag) {
            if( abrupt || !config.performHandshake ||
                (associatedConnection == null) )
            {
                proc.destroy();//kill the process
            } else {
                // Tell the process shut down gracefully
                try {
                    associatedConnection.send(Arrays.asList("STOP"));
                    startStoppingTimer();
                } catch(IOException e) {
                    proc.destroy();
                }
            }
            // Once the process exits, the monitoring thread will change
            // the state to STOPPED.
        }
    }

    public synchronized void associateConnection(MessageTransport msgTransport)
    {
        if( (associatedConnection != null) && (msgTransport != null) ) {
            throw new IllegalStateException
                      ("Process already has a connection associated with it");
        }
        this.associatedConnection = msgTransport;
    }

    public synchronized void initCompleteSignaled() {
        if(state == ProcessState.STARTING) {
            changeState(ProcessState.RUNNING);
        }
    }

    public synchronized void shuttingDownSignaled() {
        if((state == ProcessState.STARTING)||(state == ProcessState.RUNNING)) {
            changeState(ProcessState.STOPPING);
            startStoppingTimer();
        }
    }

    /**
     * Method that is called in the context of the process monitoring thread
     * to indicate that the process has exited.
     */
    protected synchronized void processEnded() {
        // If the stopping timer is running then kill it
        if(stoppingTimerTask != null) {
            this.stoppingTimerTask.cancel();
            this.stoppingTimerTask = null;
        }

        if(state == ProcessState.STOPPING) {
            changeState(ProcessState.STOPPED);
        } else {
            changeState(ProcessState.FAILED);
        }

        // Kill the monitoring threads
        if(stdoutMonThread != null) {
            this.stdoutMonThread.interrupt();
            this.stdoutMonThread = null;
        }
        if(deathMonThread != null) {
            this.deathMonThread.interrupt();
            this.deathMonThread = null;
        }
        this.proc = null;
    }

    /**
     * Changes the state of the process. This method must be called with
     * the object lock held.
     */
    protected void changeState(ProcessState newState) {

        assert Thread.holdsLock(this) :
                   "method must be called while holding the object "
                   +"lock [BaseProcessDescription.changeState]";

        // Validate the transition
        switch(newState) {
            case STARTING:
                if( (state != ProcessState.STOPPED) &&
                    (state != ProcessState.FAILED) )
                {
                    throw new IllegalStateException
                                  ("Process is already running");
                }
                break;
            case RUNNING:
                if(state != ProcessState.STARTING) {
                    throw new AssertionError
                                  ("cannot transition from current state "
                                   +"["+state+"] to new state ["+newState+"]");
                }
                break;
            case STOPPING:
                if( (state != ProcessState.STARTING) &&
                    (state!=ProcessState.RUNNING) )
                {
                    throw new IllegalStateException("process not running");
                }
                break;
            case STOPPED:
                if(state != ProcessState.STOPPING) {
                    throw new AssertionError
                                  ("cannot transition from current state "
                                   +"["+state+"] to new state ["+newState+"]");
                }
                break;
            case FAILED:
                if( (state != ProcessState.STARTING) &&
                    (state!=ProcessState.RUNNING) )
                {
                    throw new AssertionError
                                  ("cannot transition from current state "
                                   +"["+state+"] to new state ["+newState+"]");
                }
                break;
        }

        logger.log(Level.INFO, "changed state ["+state+" --> "+newState+"]");
        launcher.signalProcessStateChange(tag, state, newState);

        this.state = newState;
    }

    /**
     * Starts a timer that will forcibly terminate the process if it does
     * not exit within a specified amount of time.
     *
     * This method must be called while holding the object lock.
     */
    protected void startStoppingTimer() {
        assert Thread.holdsLock(this) :
                   "method must be called while holding the object "
                   +"lock [BaseProcessDescription.startStoppingTimer]";

        if(stoppingTimerTask == null) {
            this.stoppingTimerTask = new TimerTask() {
                public void run() {
                    stop(true);
                }
            };
            launcher.getTimer().schedule(stoppingTimerTask,config.stopTimeout);
        }
    }

    /**
     * Method whose concrete implementation starts the new process using
     * the current configuration properties. If the process fails to start
     * then an exception is thrown.
     */
    protected abstract Process spawnProcess() throws IOException;


    /**
     * Quotes and esacpes the given argument list so that it can be safely
     * used on Windows.
     */
    protected List<String> quoteWindowsArguments(List<String> argList) {

        List<String> result = new ArrayList<String>();
        for(String arg : argList) {
            if( arg.isEmpty() ) {
                // Java loses empty string arguments instead of
                // correctly translating an empty argument to ""
                result.add("\"\"");
            } else {
                // Escape quote characters & put quotes around the whole thing
                arg = arg.replace("\"", "\\\"");
                result.add("\"" + arg + "\"");
            }
        }
        return result;
    }

    /**
     * Thread class that monitors the output streams (stdout and stderr)
     * of the process and writes the contents to the boot launcher log.
     */
    private class StdoutLoggingThread extends Thread {

        public StdoutLoggingThread(String tag) {
            super("StdoutLoggingThread(" + tag + ")");
            this.setDaemon(true);
        }

        public void run() {
            try {
                BufferedReader in = 
                    new BufferedReader
                        (new java.io.InputStreamReader(proc.getInputStream()));
                while(true) {
                    String line = in.readLine();
                    if(line == null) break;
                    logger.info(line);
                }
            } catch(IOException e) {
                // The thread should exit when the process closes it's output
            }
        }
    }

    /**
     * Thread class that simply waits for the process to die; after which
     * a notification is sent to the main object.
     */
    private class ProcessDeathMonitorThread extends Thread {

        public ProcessDeathMonitorThread(String tag) {
            super("ProcessDeathMonitorThread(" + tag + ")");
            this.setDaemon(true);
        }

        public void run() {
            try {
                proc.waitFor();//wait for the process to end
                processEnded();//notify the main object
            } catch(java.lang.InterruptedException e) { /* swallow */ }
        }
    }
}
