/**

The Notice below must appear in each file of the Source Code of any
copy you distribute of the Licensed Product.  Contributors to any
Modifications may add their own copyright notices to identify their
own contributions.

License:

The contents of this file are subject to the CognitiveWeb Open Source
License Version 1.1 (the License).  You may not copy or use this file,
in either source code or executable form, except in compliance with
the License.  You may obtain a copy of the License from

  http://www.CognitiveWeb.org/legal/license/

Software distributed under the License is distributed on an AS IS
basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.  See
the License for the specific language governing rights and limitations
under the License.

Copyrights:

Portions created by or assigned to CognitiveWeb are Copyright
(c) 2003-2003 CognitiveWeb.  All Rights Reserved.  Contact
information for CognitiveWeb is available at

  http://www.CognitiveWeb.org

Portions Copyright (c) 2002-2003 Bryan Thompson.

Acknowledgements:

Special thanks to the developers of the Jabber Open Source License 1.0
(JOSL), from which this License was derived.  This License contains
terms that differ from JOSL.

Special thanks to the CognitiveWeb Open Source Contributors for their
suggestions and support of the Cognitive Web.

Modifications:

*/
/*
 * Created on Nov 1, 2006
 */

package com.bigdata.journal;

import java.util.BitSet;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import com.bigdata.util.TimestampFactory;

/**
 * The transaction server is responsible for generating unique transaction
 * identifiers, determining when a transaction is "dead" (through inactivity),
 * and notifying journals when they may GC completed transactions. The
 * transaction server may either be integrated into an embedded database or run
 * as a replicated service for a distributed database. The transaction
 * identifier is simply a unique timestamp with nanosecond precision. The
 * transaction identifiers are generated by a centralized service. For an
 * embedded database, that service is local. For a distributed database the
 * service must be resolved, e.g., using JINI.
 * 
 * @todo Define an API for the transaction server. Implement an embedded version
 *       of the server for a single segment and write its test suite. Implement
 *       an embedded version server for multiple segments (handles 2/3 phase
 *       commit protocol on a single host) and write its test suite. Implement a
 *       robust, discoverable, replicated version of the service handling
 *       multiple segments and devise a test strategy. Characterize performance
 *       curves in terms of latency and maximum concurrency.
 * 
 * @todo The distributed database version of the transaction server needs to
 *       know where to find each segment. In the embedded distributed scenario,
 *       the segments are all local (within the VM). In the non-embedded
 *       scenario, the segments need to be discovered using the same protocol
 *       that the clients use to discover segments.
 * 
 * @todo A centralized transaction service will create an eventual concurrency
 *       bottleneck. There must be 2-3 RPCs to the transaction server per
 *       transaction (start -> prepare | abort -> commit), plus a probable
 *       heartbeat. The #of concurrent client connections to the server will be
 *       a limiting factor unless we use UDP (vs TCP) for the transaction server
 *       RPC protocol. The bottleneck will probably be upwards of 1000s of
 *       concurrent transactions. I would expect that 10k concurrent
 *       transactions could be the limit, and should certainly be an internal
 *       target. Achieving higher concurrency will require more localized
 *       mechanisms, e.g., single row atomic updates. There is also a use case
 *       for read uncommitted transactions in order to permit earlier GC with
 *       very very long running transactions, which would otherwise defer GC
 *       until their completion.
 * 
 * @todo Concurrent transactions define a dependency graph of (a) transactions
 *       that have written on the committed state of another transaction; and
 *       (b) transaction that can read from the committed state of another
 *       transaction. We can GC transactions that statisfy (a) once tranactions
 *       that satisify (b) have all completed (either aborted or committed).
 *       This information can be further refined by the segments resources that
 *       a transaction has read or written on. Maintaining that dependency
 *       information in a restart safe manner (e.g., by a replicated service)
 *       will have its own cost.
 * 
 * @todo Support readCommitted isolation. A readCommitted transaction performs
 *       reads against the current committed state of the journal and does not
 *       block GC (writes are still buffered by an isolated object index). This
 *       has the consequence that changes committed by concurrent transactions
 *       will be visible and reduces resources otherwise consumed by historical
 *       versions preserved until GC. A readOnly + readCommitted transaction
 *       does not impose a resource burden since it only reads from the current
 *       committed state of the segment and never writes.
 * 
 * @author <a href="mailto:thompsonbry@users.sourceforge.net">Bryan Thompson</a>
 * @version $Id$
 */
public class TransactionServer {

    /**
     * Class modeling transaction metadata.
     * 
     * @author <a href="mailto:thompsonbry@users.sourceforge.net">Bryan Thompson</a>
     * @version $Id$
     */
    static class TxMetadata {

        /**
         * The transaction timestamp.
         */
        final long ts;
        /**
         * True iff the transaction is read-only.
         */
        final boolean readOnly;
        /**
         * True iff the transaction permits reads of updates committed by
         * concurrent transactions.
         */
        final boolean readCommitted;
        /**
         * The timestamp (ms) of the last heartbeat received for the
         * transaction. Timestamps are generated by the clock on which the
         * transaction server is running.
         * 
         * @todo Periodically scan all transactions and abort those that have
         *       not received a heartbeat "recently".
         */
        long heartbeat;
//        /**
//         * The transaction run state (initially active).
//         */
//        RunState runState;
        /**
         * A bit is set for each segment opened by the transaction.
         */
        BitSet openSegments;
        /**
         * A set of active transactions for which this transaction serves as the
         * ground state. This collection is undefined until this transaction
         * commits. Once this transaction commits, any new transactions that
         * start before the next transaction commits will use this transaction
         * as their ground state. Those transactions will be tracked in this
         * collection while they are active. Any transaction that uses this
         * transaction as its ground state and successfully commits will be
         * moved from {@link #active} to {@link #committed}. Once there are no
         * more {@link #active} transactions using this transaction as their
         * ground state, any {@link #committed} transactions for this ground
         * state may be GCd.
         * 
         * @todo Add constraint on [active] that new entries are not permitted
         *       once [committed] is non-empty.
         * 
         * @todo Add constraint on [active] that entries are not permitted until
         *       this transaction is [committed].
         */
        Map<Long,TxMetadata> active = new ConcurrentHashMap<Long, TxMetadata>();
        /**
         * Transactions that emerge from the ground state of this transaction
         * and then commit are tracked here until they can be GCd. They are not
         * GCd until all active transactions that emerge from this ground state
         * have completed (aborted or committed). If this collection has at
         * least one entry, then we are guarenteed that no new transactions will
         * emerge from this ground state.
         */
        Map<Long,TxMetadata> committed = new ConcurrentHashMap<Long, TxMetadata>();
        
        public TxMetadata(long ts,boolean readOnly,boolean readCommitted) {
            this.ts = ts;
            this.readOnly = readOnly;
            this.readCommitted = readCommitted;
            
//            runState = RunState.ACTIVE;
            
            heartbeat = System.nanoTime();
            
            openSegments = new BitSet();
        }
        
        public void openSegment(int segment) {
            
            openSegments.set(segment);
            
        }
        
    }
    
    /**
     * Map containing metadata for active transactions.
     */
    private Map<Long, TxMetadata> transactions = new ConcurrentHashMap<Long, TxMetadata>(
            1000);
    
    /**
     * <p>
     * Map containing metadata for committed transactions. The metadata for a
     * committed transaction is retained until all transactions emerging from
     * the ground state of that committed transaction have completed. We track
     * each active transaction for a given ground state and each transaction
     * that commits for a given ground state. When there are no more active
     * transactions for a given ground state, we GC all transactions that
     * committed for that ground state and remove the transaction metadata for
     * the ground state from this map.
     * </p>
     * <p>
     * Note: By "ground state" I mean a stable state that results on the journal
     * after a transaction commits and that serves as the baseline state for any
     * transactions starting after that commit point and before the next commit
     * point.
     * </p>
     */
    private Map<Long, TxMetadata> groundStates = new ConcurrentHashMap<Long, TxMetadata>();

    /**
     * A reference to the transaction metadata for the transaction that will
     * serve as the ground state for any new transactions. The groundState
     * transaction is updated each time a transaction commits. This field is
     * initially null.
     * 
     * @todo Perhaps this should be a timestamp rather than a reference?
     * 
     * @todo Provide for bootstrapping this field. For a new database, the field
     *       might be ts0. When re-starting an entire database, the value of the
     *       field is the largest timestamp committed on any segment.
     * 
     * @todo Updates to this field MUST be atomic with respect to the creation
     *       of new transactions.
     */
    private TxMetadata groundState = null;
    
    /**
     * 
     */
    public TransactionServer() {
    }

    /**
     * Start a new transaction.
     * 
     * @param segment
     *            The first segment that will be opened by the transaction or -1
     *            if the client elects not to notify the transaction server of
     *            the first segment at the time that the transaction starts.
     * 
     * @param readOnly
     *            true iff the transaction is read-only.
     * 
     * @param readCommitted
     *            true iff the transaction is not fully isolated (reads of
     *            updates committed by concurrent transactions are permitted).
     * 
     * @return The unique transaction identifier assigned to the new
     *         transaction.
     * 
     * @todo This API suggests that -1 is not a valid segment identifier. We
     *       could have made 0 the invalid segment identifier just as easily. In
     *       practice, I expect that segment identifiers will be positive
     *       integers.
     */
    public long startTx(int segment, boolean readOnly, boolean readCommitted) {
        
        long ts = TimestampFactory.nextNanoTime();
        
        transactions.put(ts, new TxMetadata(ts,readOnly,readCommitted));
        
        return ts;
        
    }

    /**
     * Abort a transaction. Notice will be issued to all segments that have been
     * written or read by the transaction. The transaction identifier will be
     * invalidated.
     * 
     * @param ts
     *            The transaction identifier.
     */
    public void abortTx(long ts) {

        TxMetadata tx = transactions.remove(ts);
        
        if( tx == null ) {

            /*
             * @todo differentiate between transactions that were never started
             * and that have been completed by global knowledge of the ordering
             * of assigned timestamps.
             */
            
            throw new IllegalArgumentException("Unknown transaction: "+ts);
            
        }

        /*
         * Notify open segments of tx abort.
         * 
         * @todo Should send messages in parallel and gather responses.
         * 
         * @todo Return to the caller when all segments have been aborted or
         * immediately, letting the transaction server handle the cleanup?
         */
        BitSet openSegments = tx.openSegments;

        for( int i=0; i<openSegments.length(); ) {
            
            int ndx = openSegments.nextSetBit( i );
            
            if( ndx == -1 ) break;
            
            notifyAbort( ndx, ts );
            
            i = ndx;
            
        }
        
    }
    
    /**
     * Commit a transaction. When the transaction is distributed, this prepares
     * the transaction and then commits the transaction according to a
     * multi-phase commit protocol. Notice will be issued to all segments that
     * have been written or read by the transaction. The transaction identifier
     * will be invalidated.
     * 
     * @param ts
     *            The transaction identifier.
     */
    public void commitTx(long ts) {
        
        TxMetadata tx = transactions.remove(ts);
        
        if( tx == null ) {

            /*
             * @todo differentiate between transactions that were never started
             * and that have been completed by global knowledge of the ordering
             * of assigned timestamps.
             */
            
            throw new IllegalArgumentException("Unknown transaction: "+ts);
            
        }

        /*
         * Notify open segments of tx prepare
         * 
         * @todo Should send messages in parallel and gather responses.
         */
        BitSet openSegments = tx.openSegments;

        for( int i=0; i<openSegments.length(); ) {
            
            int ndx = openSegments.nextSetBit( i );
            
            if( ndx == -1 ) break;
            
            notifyPrepare( ndx, ts );
            
            i = ndx;
            
        }
        
        /*
         * @todo Wait for all notified segments to respond.  If one or more
         * does not prepare successfully or it one or more does not respond
         * within a timeout, then abort the transaction.
         */
        
        /*
         * Notify open segments of tx commit.
         * 
         * @todo Should send messages in parallel and gather responses.
         */

        for( int i=0; i<openSegments.length(); ) {
            
            int ndx = openSegments.nextSetBit( i );
            
            if( ndx == -1 ) break;
            
            notifyCommit( ndx, ts );
            
            i = ndx;
            
        }
        
    }
    
    /**
     * Clients issue heartbeats to notify the transaction server that the
     * transaction is still running. A transaction that does not receive a
     * heartbeat within a required interval will be aborted.
     * 
     * @param ts
     *            The transaction identifier.
     */
    public void heartbeat(long ts) {
        
        TxMetadata tx = transactions.get(ts);
        
        if( tx == null ) {
            
            // @todo protocol error.
            
            throw new IllegalArgumentException("transaction: "+ts);
            
        }
        
        tx.heartbeat = System.currentTimeMillis();
        
    }
    
    /**
     * Notice by the client that it will open the segment. Since work may be
     * done on a transaction by multiple processes, we permit multiple "open"
     * requests for the same segment. Segments that are opened by a transaction
     * are tracked and will receive prepare, commit or abort messages for that
     * transaction. Note that there is no sense of "closing" a segment. The set
     * of segments opened by a transaction determines the segments that must
     * receive notices generated by transaction events.
     * 
     * @param ts
     *            The transaction identifier.
     * @param segment
     *            The segment identifier.
     */
    public void openSegment(long ts, int segment) {

        TxMetadata tx = transactions.get(ts);
        
        if( tx == null ) {
            
            // @todo protocol error.
            
            throw new IllegalArgumentException("transaction: "+ts);
            
        }
        
        tx.openSegment(segment);

    }

    /**
     * Send the segment notice that it must abort the transaction.
     * 
     * @param segment
     *            The segment identifier.
     * @param ts
     *            The transaction identifier.
     */
    protected void notifyAbort(int segment, long ts) {

    }

    /**
     * Send the segment notice that it must prepare the transaction.
     * 
     * @param segment
     *            The segment identifier.
     * @param ts
     *            The transaction identifier.
     */
    protected void notifyPrepare(int segment, long ts) {

    }

    /**
     * Send the segment notice that it must commit the transaction.
     * 
     * @param segment
     *            The segment identifier.
     * @param ts
     *            The transaction identifier.
     */
    protected void notifyCommit(int segment, long ts) {

    }

    /**
     * Send the segment notice that it must GC the transaction.
     * 
     * @param segment
     *            The segment identifier.
     * @param ts
     *            The transaction identifier.
     * 
     * @todo Typically, the transaction server will generate GC notices for
     *       multiple transactions at once (one for each transaction that
     *       committed that emerged from a given ground state).  Those notices
     *       could be combined to reduce RPC traffic.
     */
    protected void notifyGC(int segment, long ts) {

    }

}
