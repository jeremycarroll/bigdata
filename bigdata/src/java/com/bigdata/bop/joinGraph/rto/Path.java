package com.bigdata.bop.joinGraph.rto;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;

import com.bigdata.bop.BOp;
import com.bigdata.bop.BOpUtility;
import com.bigdata.bop.IConstraint;
import com.bigdata.bop.IPredicate;
import com.bigdata.bop.engine.QueryEngine;

/**
 * A join path is an ordered sequence of N {@link Vertex vertices} and
 * represents an ordered series of N-1 joins.
 * <p>
 * During exploration, the {@link Path} is used to develop an estimate of the
 * cost of different join paths which explore the {@link Vertex vertices} in a
 * {@link JGraph join graph}, possibly under some set of {@link IConstraint}s.
 * The estimated cost of the join path is developed from a sample of the initial
 * {@link Vertex} followed by the cutoff sample of each join in the join path.
 * Join paths may be re-sampled in successive rounds at a greater sample size in
 * order to improve the accuracy and robustness of the estimated cost for the
 * join path.
 * <p>
 * Each join path reflects a specific history. The cutoff sample for the initial
 * vertex can be shared across join paths since there is no prior history. This
 * is true even when we re-sample the vertex at the start of each round. The
 * cutoff sample for each join reflects the history of joins. It can only be
 * shared with join paths having the same history up to that vertex. For
 * example, the following join paths can share estimates of the vertices A, B,
 * and C but not D or E.
 * 
 * <pre>
 * p1: {A, B, C, E, D}
 * p2: {A, B, C, D, E}
 * </pre>
 * 
 * This is because their histories diverge after the (B,C) join.
 * <p>
 * In each successive round of exploration, each join path is replaced by one or
 * more one-step extensions of that path. The extensions are generated by
 * considering the {@link Vertex vertices} in the join graph which are not yet
 * in use within the join path. The join paths which spanning the same unordered
 * set of vertices in a given round of exploration compete based on their
 * estimated cost. The winner is the join path with the lowest estimated cost.
 * The losers are dropped from further consideration in order to prune the
 * search space. See {@link JGraph} which manages the expansion and competition
 * among join paths.
 * <p>
 * When considering {@link Vertex vertices} which can extend the join path, we
 * first select constrained joins. Only if there are no remaining constrained
 * joins will a join path be extended by an unconstrained join. A constrained
 * join is one which shares a variable with the existing join path. The variable
 * may either be shared directly via the {@link IPredicate}s or indirectly via
 * an {@link IConstraint} which can be evaluated for the {@link Vertex} under
 * consideration given the set of variables which are already known to be bound
 * for the join path. An unconstrained join is one where there are no shared
 * variables and always results in a full cross-product. Unconstrained joins are
 * not chosen unless there are no available constrained joins.
 */
public class Path {

//    private static final transient Logger log = Logger.getLogger(Path.class);

    /**
     * An immutable ordered list of the edges in the (aka the sequence of
     * joins represented by this path).
     * 
     * @deprecated by with {@link #vertices}.
     */
    final List<Edge> edges;

    /**
     * An ordered list of the vertices in the {@link Path}.
     * 
     * TODO Replace {@link #edges} with {@link #vertices} and declare a
     * second array with the {@link VertexSample} for the initial vertex
     * followed by the {@link EdgeSample} for each cutoff join in the path.
     */
    final Vertex[] vertices;

    /**
     * An ordered list of the {@link IPredicate}s in the {@link #vertices}. This
     * is computed by the constructor and cached as it is used repeatedly.
     */
    private final IPredicate<?>[] preds;
    
    /**
     * The sample obtained by the step-wise cutoff evaluation of the ordered
     * edges of the path.
     * <p>
     * Note: This sample is generated one edge at a time rather than by
     * attempting the cutoff evaluation of the entire join path (the latter
     * approach does allow us to limit the amount of work to be done to
     * satisfy the cutoff).
     */
    public EdgeSample sample;

    /**
     * The cumulative estimated cardinality of the path. This is zero for an
     * empty path. For a path consisting of a single edge, this is the
     * estimated cardinality of that edge. When creating a new path by
     * adding an edge to an existing path, the cumulative cardinality of the
     * new path is the cumulative cardinality of the existing path plus the
     * estimated cardinality of the cutoff join of the new edge given the
     * input sample of the existing path.
     * 
     * @todo track this per vertex as well as the total for more interesting
     * traces in showPath(Path).
     */
    final public long cumulativeEstimatedCardinality;

    public String toString() {
        final StringBuilder sb = new StringBuilder();
        sb.append("Path{[");
        boolean first = true;
        for (Vertex v : vertices) {
            if (!first)
                sb.append(",");
            sb.append(v.pred.getId());
            first = false;
        }
//        for (Edge e : edges) {
//            if (!first)
//                sb.append(",");
//            sb.append(e.getLabel());
//            first = false;
//        }
        sb.append("],cumEstCard=" + cumulativeEstimatedCardinality
                + ",sample=" + sample + "}");
        return sb.toString();
    }

    /**
     * Create an empty path.
     */
    public Path() {
        this.edges = Collections.emptyList();
        this.vertices = getVertices(edges);
        this.preds = getPredicates(vertices);
        this.cumulativeEstimatedCardinality = 0;
        this.sample = null;
    }

    /**
     * Create a path from a single edge.
     * 
     * @param e
     *            The edge.
     */
    public Path(final Edge e) {

        if (e == null)
            throw new IllegalArgumentException();

        if (e.sample == null)
            throw new IllegalArgumentException("Not sampled: " + e);

        this.edges = Collections.singletonList(e);

        this.vertices = getVertices(edges);

        this.preds = getPredicates(vertices);
        
        this.sample = e.sample;

        this.cumulativeEstimatedCardinality = e.sample.estimatedCardinality;

    }

    /**
     * Constructor used by {@link #addEdge(QueryEngine, int, Edge)}
     * 
     * @param edges
     *            The edges in the new path.
     * @param cumulativeEstimatedCardinality
     *            The cumulative estimated cardinality of the new path.
     * @param sample
     *            The sample from the last
     */
    private Path(final List<Edge> edges,
            final long cumulativeEstimatedCardinality,
            final EdgeSample sample) {

        if (edges == null)
            throw new IllegalArgumentException();

        if (cumulativeEstimatedCardinality < 0)
            throw new IllegalArgumentException();

        if (sample == null)
            throw new IllegalArgumentException();

        this.edges = Collections.unmodifiableList(edges);

        this.vertices = getVertices(edges);
        
        this.preds = getPredicates(vertices);
        
        this.cumulativeEstimatedCardinality = cumulativeEstimatedCardinality;

        this.sample = sample;
        
    }

    /**
     * Return the #of vertices in this join path.
     */
    public int getVertexCount() {
        
        return vertices.length;
        
    }
    
    /**
     * Return <code>true</code> iff the {@link Path} contains at least one
     * {@link Edge} for that {@link Vertex}.
     * 
     * @param v
     *            The vertex
     * 
     * @return true if the vertex is already part of the path.
     */
    public boolean contains(final Vertex v) {

        if (v == null)
            throw new IllegalArgumentException();

        for (Vertex x : vertices) {
         
            if (v == x)
                return true;
            
        }
//        for (Edge e : edges) {
//
//            if (e.v1 == v || e.v2 == v)
//                return true;
//
//        }

        return false;
    }

    /**
     * Return <code>true</code> if this path is an unordered variant of the
     * given path (same vertices in any order).
     * 
     * @param p
     *            Another path.
     * 
     * @return <code>true</code> if this path is an unordered variant of the
     *         given path.
     */
    public boolean isUnorderedVariant(final Path p) {

        if (p == null)
            throw new IllegalArgumentException();

        if (vertices.length != p.vertices.length) {
            /*
             * Fast rejection. This assumes that each edge after the first
             * adds one distinct vertex to the path. That assumption is
             * enforced by #addEdge().
             */
            return false;
        }

        final Vertex[] v1 = this.vertices;
        final Vertex[] v2 = p.vertices;

        if (v1.length != v2.length) {

            // Reject (this case is also covered by the test above).
            return false;
            
        }

        /*
         * Scan the vertices of the caller's path. If any of those vertices
         * are NOT found in this path the paths are not unordered variations
         * of one another.
         */
        for (int i = 0; i < v2.length; i++) {

            final Vertex tmp = v2[i];

            boolean found = false;
            for (int j = 0; j < v1.length; j++) {

                if (v1[j] == tmp) {
                    found = true;
                    break;
                }

            }

            if (!found) {
                return false;
            }

        }

        return true;

    }

    /**
     * Return the vertices in this path (in path order). For the first edge,
     * the minimum cardinality vertex is always reported first (this is
     * critical for producing the correct join plan). For the remaining
     * edges in the path, the unvisited is reported.
     * 
     * @return The vertices (in path order).
     */
    public List<Vertex> getVertices() {

        return Collections.unmodifiableList(Arrays.asList(vertices));

    }

    /**
     * Return the {@link IPredicate}s associated with the vertices of the
     * join path in path order.
     * 
     * @see #getVertices()
     */
    public IPredicate<?>[] getPredicates() {

        return preds;

    }

    /**
     * Return the {@link BOp} identifiers of the predicates associated with
     * each vertex in path order.
     */
    public int[] getVertexIds() {
        
//        return getVertexIds(edges);
        
        return BOpUtility.getPredIds(preds);
        
    }
    
    /**
     * Return the vertices in this path (in path order). For the first edge,
     * the minimum cardinality vertex is always reported first (this is
     * critical for producing the correct join plan). For the remaining
     * edges in the path, the unvisited is reported.
     * 
     * @return The vertices (in path order).
     * 
     * TODO Drop this when we drop {@link Path#edges}.
     */
    static private Vertex[] getVertices(final List<Edge> edges) {
        
        final Set<Vertex> tmp = new LinkedHashSet<Vertex>();

        for (Edge e : edges) {

            if (tmp.isEmpty()) {
                /*
                 * The first edge is handled specially in order to report
                 * the minimum cardinality vertex first.
                 */
                tmp.add(e.getMinimumCardinalityVertex());
                tmp.add(e.getMaximumCardinalityVertex());

            } else {

                tmp.add(e.v1);

                tmp.add(e.v2);

            }
            
        }
        
        final Vertex[] a = tmp.toArray(new Vertex[tmp.size()]);
        
        return a;
        
    }

    /**
     * Return the predicates associated with the vertices.
     * 
     * @param vertices
     *            The vertices in the selected evaluation order.
     * 
     * @return The predicates associated with those vertices in the same order.
     */
    static private IPredicate<?>[] getPredicates(final Vertex[] vertices) {

        // The predicates in the same order as the vertices.
        final IPredicate<?>[] preds = new IPredicate[vertices.length];

        for (int i = 0; i < vertices.length; i++) {

            preds[i] = vertices[i].pred;

        }

        return preds;

    }

    /**
     * Return the {@link BOp} identifiers of the predicates associated with
     * each vertex in path order.
     * 
     * TODO Drop when we drop {@link #edges}.
     */
    static int[] getVertexIds(final List<Edge> edges) {

        final Set<Vertex> tmp = new LinkedHashSet<Vertex>();
        
        for (Edge e : edges) {
        
            tmp.add(e.v1);
            
            tmp.add(e.v2);
            
        }
        
        final Vertex[] a = tmp.toArray(new Vertex[tmp.size()]);

        final int[] b = new int[a.length];
        
        for (int i = 0; i < a.length; i++) {
        
            b[i] = a[i].pred.getId();
            
        }
        
        return b;
        
    }

    /**
     * Return <code>true</code> if this path begins with the given path.
     * 
     * @param p
     *            The given path.
     * 
     * @return <code>true</code> if this path begins with the given path.
     * 
     * @todo unit tests.
     */
    public boolean beginsWith(final Path p) {

        if (p == null)
            throw new IllegalArgumentException();

        if (vertices.length > p.vertices.length) {
            // Proven false since the caller's path is longer.
            return false;
        }

        for (int i = 0; i < p.vertices.length; i++) {
            final Vertex vSelf = vertices[i];
            final Vertex vOther = p.vertices[i];
//            final Edge eSelf = edges.get(i);
//            final Edge eOther = p.edges.get(i);
//            if (eSelf != eOther) {
            if (vSelf != vOther) {
                return false;
            }
        }

        return true;
    }

    /**
     * Add an edge to a path, computing the estimated cardinality of the new
     * path, and returning the new path. The cutoff join is performed using
     * the {@link #sample} of <i>this</i> join path and the actual access
     * path for the target vertex.
     * 
     * @param queryEngine
     * @param limit
     * @param e
     *            The edge.
     * 
     * @return The new path. The materialized sample for the new path is the
     *         sample obtained by the cutoff join for the edge added to the
     *         path.
     * 
     * @throws Exception
     */
    public Path addEdge(final QueryEngine queryEngine, final int limit,
            final Edge e) throws Exception {

        if (e == null)
            throw new IllegalArgumentException();

        // Figure out which vertices are already part of this path.
        final boolean v1Found = contains(e.v1);
        final boolean v2Found = contains(e.v2);

        if (!v1Found && !v2Found)
            throw new IllegalArgumentException(
                    "Edge does not extend path: edge=" + e + ", path="
                            + this);

        if (v1Found && v2Found)
            throw new IllegalArgumentException(
                    "Edge already present in path: edge=" + e + ", path="
                            + this);

        // The vertex which is already part of this path.
        final Vertex sourceVertex = v1Found ? e.v1 : e.v2;

        // The new vertex, which is not part of this path.
        final Vertex targetVertex = v1Found ? e.v2 : e.v1;

        /*
         * Chain sample the edge.
         * 
         * Note: ROX uses the intermediate result I(p) for the existing path as
         * the input when sampling the edge. The corresponding concept for us is
         * the sample for this Path, which will have all variable bindings
         * produced so far. In order to estimate the cardinality of the new join
         * path we have to do a one step cutoff evaluation of the new Edge,
         * given the sample available on the current Path.
         * 
         * FIXME It is possible for the path sample to be empty. Unless the
         * sample also happens to be exact, this is an indication that the
         * estimated cardinality has underflowed. We track the estimated
         * cumulative cardinality, so this does not make the join path an
         * immediate winner, but it does mean that we can not probe further on
         * that join path as we lack any intermediate solutions to feed into the
         * downstream joins. To resolve that, we have to increase the sample
         * limit (unless the path is the winner, in which case we can fully
         * execute the join path segment and materialize the results and use
         * those to probe further, but this will require the use of the memory
         * manager to keep the materialized intermediate results off of the Java
         * heap).
         */

        final EdgeSample edgeSample = e.estimateCardinality(queryEngine,
                limit, sourceVertex, targetVertex,
                this.sample // the source sample.
//                this.sample.estimatedCardinality,
//                this.sample.estimateEnum == EstimateEnum.Exact,
//                this.sample.limit,//
//                this.sample.sample// the sample fed into the cutoff join.
                );

        {

            final List<Edge> edges = new ArrayList<Edge>(
                    this.edges.size() + 1);

            edges.addAll(this.edges);

            edges.add(e);

            final long cumulativeEstimatedCardinality = this.cumulativeEstimatedCardinality
                    + edgeSample.estimatedCardinality;

            // Extend the path.
            final Path tmp = new Path(edges,
                    cumulativeEstimatedCardinality, edgeSample);

            return tmp;

        }

    }

}
