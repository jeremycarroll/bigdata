/**

Copyright (C) SYSTAP, LLC 2006-2011.  All rights reserved.

Contact:
     SYSTAP, LLC
     4501 Tower Road
     Greensboro, NC 27410
     licenses@bigdata.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
package com.bigdata.bop.solutions;

import java.util.Arrays;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.FutureTask;

import org.apache.log4j.Logger;

import com.bigdata.bop.BOp;
import com.bigdata.bop.BOpContext;
import com.bigdata.bop.BOpUtility;
import com.bigdata.bop.Constant;
import com.bigdata.bop.HashMapAnnotations;
import com.bigdata.bop.IBind;
import com.bigdata.bop.IBindingSet;
import com.bigdata.bop.IConstant;
import com.bigdata.bop.IConstraint;
import com.bigdata.bop.IValueExpression;
import com.bigdata.bop.IVariable;
import com.bigdata.bop.IVariableFactory;
import com.bigdata.bop.Var;
import com.bigdata.bop.aggregate.IAggregate;
import com.bigdata.bop.bindingSet.ListBindingSet;
import com.bigdata.bop.engine.BOpStats;
import com.bigdata.htree.HTree;
import com.bigdata.rdf.error.SparqlTypeErrorException;
import com.bigdata.relation.accesspath.IAsynchronousIterator;
import com.bigdata.relation.accesspath.IBlockingBuffer;
import com.bigdata.util.InnerCause;

/**
 * An in-memory at-once generalized aggregation operator.
 * 
 * @author <a href="mailto:thompsonbry@users.sourceforge.net">Bryan Thompson</a>
 * @version $Id: DistinctElementFilter.java 3466 2010-08-27 14:28:04Z
 *          thompsonbry $
 * 
 *          TODO Nearly the same approach could be applied with pipelined
 *          evaluation. During each evaluation pass, any new input solutions
 *          would be pushed into the {@link HTree} used to group the solutions.
 *          On the last evaluation pass we would then scan each group in turn,
 *          computing the aggregation function. This provides a means to
 *          incrementally transfer data from the Java heap to the native heap.
 *          However, that same purpose might be served by writing an "at-once"
 *          operator whose inputs are buffered on the native heap. We just need
 *          to specify how the aggregation operator will gain access to the
 *          input solutions without copying them (alternatively, the input
 *          solutions could be buffered by an {@link HTree} which is already
 *          imposing the GROUP_BY constraint.) This is in turn very similar to
 *          breaking down the generalized aggregation operator into a GROUP_BY
 *          operator and an aggregation operator running over the {@link HTree}
 *          (and set of groups) generated by the GROUP_BY operator.
 *          <p>
 *          1. There are several optimizations, but the basic approach is to
 *          GROUP each incoming solution, appending it to the multiset of
 *          solutions for its computed GROUP BY key. Then, for each GROUP and
 *          each SELECTed value expression, compute the aggregate function over
 *          that group and set it on an output solution. Emit an output solution
 *          each time we finish with the value expressions in a GROUP. If the
 *          aggregate function uses distinct:=true, e.g., AVG(DISTINCT X), then
 *          we have to collect the DISTINCT values of X, where X may be a value
 *          expression and not just a simple variable, and compute the aggregate
 *          function over those DISTINCT values (value set). Otherwise we
 *          compute the aggregate function over all values for the value
 *          expression in the group.
 * 
 *          2. One optimizations applies when distinct:=false for all SELECTed
 *          value expressions. In this case we can proceed GROUP by GROUP,
 *          evaluating each aggregation function incrementally as we visit the
 *          each solution in the current group.
 * 
 *          3. Another optimization applies when the aggregation functions can
 *          be computed solution by solution. Rather than storing the solution
 *          multisets for each group, we can have one "counter" for each
 *          aggregate function in an aggregate solution set for a given group.
 *          For each solution which is assigned to a given group, we compute the
 *          inner value expression for the aggregate function and then present
 *          that value to the aggregate function (alternatively, we evaluate the
 *          aggregation function within the context of its group-local state).
 * 
 *          Do we need a distinct API for each of these optimizations?
 * 
 *          Are there aggregation functions which can be optimized by (2) but
 *          not by (3)?
 * 
 *          TODO Modify to rewrite AVERAGE as SUM()/COUNT() in preparation for a
 *          more optimal evaluation when we the aggregate does not use DISTINCT
 *          and when there are no dependencies among the aggregate expressions
 *          (e.g., SUM(x)+1 is fine, as is SUM(x)+SUM(y), but SUM(x+AVG(x))
 *          introduces a dependency which prevents us from optimizing the
 *          aggregation using per-group incremental pipelined evaluation).
 */
public class MemoryGroupByOp extends GroupByOp implements IVariableFactory {

    /**
     * 
     */
    private static final long serialVersionUID = 1L;

	private static final transient Logger log = Logger
			.getLogger(MemoryGroupByOp.class);
    
    public interface Annotations extends GroupByOp.Annotations,
            HashMapAnnotations {

	}

    /**
     * Required deep copy constructor.
     */
    public MemoryGroupByOp(final MemoryGroupByOp op) {
        super(op);
    }

    /**
     * Required shallow copy constructor.
     */
    public MemoryGroupByOp(final BOp[] args,
            final Map<String, Object> annotations) {

        super(args, annotations);

        switch (getEvaluationContext()) {
		case CONTROLLER:
			break;
		default:
			throw new UnsupportedOperationException(
					Annotations.EVALUATION_CONTEXT + "="
							+ getEvaluationContext());
		}

        assertAtOnceJavaHeapOp();
        
	}
    
    /**
     * @see Annotations#INITIAL_CAPACITY
     */
    public int getInitialCapacity() {

        return getProperty(Annotations.INITIAL_CAPACITY,
                Annotations.DEFAULT_INITIAL_CAPACITY);

    }

    /**
     * @see Annotations#LOAD_FACTOR
     */
    public float getLoadFactor() {

        return getProperty(Annotations.LOAD_FACTOR,
                Annotations.DEFAULT_LOAD_FACTOR);

    }

    public FutureTask<Void> eval(final BOpContext<IBindingSet> context) {

        return new FutureTask<Void>(new GroupByTask(this, context));
        
    }

    /**
     * Return a new anonymous variable (this is overridden by some unit tests in
     * order to have predictable variable names).
     */
    public IVariable<?> var() {

        return Var.var();

    }

    /**
     * Wrapper used for the solution groups in the {@link ConcurrentHashMap}.
     */
    private static class SolutionGroup {

		/** The hash code for {@link #vals}. */
		private final int hash;

        /**
         * The computed values for the groupBy value expressions in the order in
         * which they were declared.
         */
        private final IConstant<?>[] vals;

		public String toString() {
			return super.toString() + //
					"{group=" + Arrays.toString(vals) + //
					"}";
		}

        /**
         * Return a new {@link SolutionGroup} given the value expressions and
         * the binding set.
         * 
         * @param groupBy
         *            The value expressions to be computed.
         * @param bset
         *            The binding set.
         * 
         * @return The new {@link SolutionGroup} -or- <code>null</code> if any
         *         of the value expressions evaluates or a <code>null</code>
         *         -OR- throws a {@link SparqlTypeErrorException}.
         */
        static SolutionGroup newInstance(final IValueExpression<?>[] groupBy,
                final IBindingSet bset) {

            final IConstant<?>[] r = new IConstant<?>[groupBy.length];

            for (int i = 0; i < groupBy.length; i++) {

                final Object asBound;
                try {
                    /*
                     * TODO This has a side-effect on the solution, which means
                     * that it needs to be mutable and we have to store the
                     * modified solution. However, it might be nicer to NOT have
                     * a side effect on the incoming solution. That means that
                     * it can continue to be buffered in a read-only encoding on
                     * the native heap and all we need to do here is associate
                     * it with the appropriate group. We can easily re-compute
                     * the GROUP_BY value expressions when we actually evaluate
                     * the aggregates over the solutions in a solution group. At
                     * that point, the solution is once again materialized in
                     * memory on the JVM.
                     */
                    asBound = groupBy[i].get(bset);
                } catch (SparqlTypeErrorException ex) {
                    // Drop solution.
                    return null;
                }
                if (asBound == null) {
                    // Drop solution.
                    return null;
                }
                @SuppressWarnings({ "rawtypes", "unchecked" })
                final IConstant<?> x = new Constant(asBound);
                r[i] = x;

            }

            return new SolutionGroup(r);
            
        }

        private SolutionGroup(final IConstant<?>[] vals) {
            this.vals = vals;
            this.hash = java.util.Arrays.hashCode(vals);
        }

        public int hashCode() {
            return hash;
        }

        public boolean equals(final Object o) {
            if (this == o)
                return true;
            if (!(o instanceof SolutionGroup)) {
                return false;
            }
            final SolutionGroup t = (SolutionGroup) o;
            if (vals.length != t.vals.length)
                return false;
            for (int i = 0; i < vals.length; i++) {
                if (vals[i] == t.vals[i])
                    continue;
                if (vals[i] == null)
                    return false;
                if (!vals[i].equals(t.vals[i]))
                    return false;
            }
            return true;
        }

    } // SolutionGroup

    /**
     * A multiset of solutions associated with a {@link SolutionGroup}.
     */
    private static class SolutionMultiSet {

        private List<IBindingSet> solutions = new LinkedList<IBindingSet>();

        public void add(final IBindingSet bset) {

            if(bset == null)
                throw new IllegalArgumentException();
            
            solutions.add(bset);
            
        }

    }
    
    /**
     * Task executing on the node.
     */
    static private class GroupByTask implements Callable<Void> {

        private final BOpContext<IBindingSet> context;

        private final IGroupByState groupByState;

        /**
         * A map whose keys are the computed bindings on the GROUP_BY
         * expressions and whose values are the solution multisets which fall
         * into a given group.
         */
        private final LinkedHashMap<SolutionGroup, SolutionMultiSet> map;

        private final IGroupByRewriteState rewrite;
        
        private final IValueExpression<?>[] groupBy;

//        private final IValueExpression<?>[] select;

//        private final IConstraint[] having;

        GroupByTask(final MemoryGroupByOp op,
                final BOpContext<IBindingSet> context) {
        	
            this.context = context;

            this.groupByState = new GroupByState(//
                    (IValueExpression<?>[]) op.getRequiredProperty(GroupByOp.Annotations.SELECT), //
                    (IValueExpression<?>[]) op.getProperty(GroupByOp.Annotations.GROUP_BY), //
                    (IConstraint[]) op.getProperty(GroupByOp.Annotations.HAVING)//
            );

            this.rewrite = new GroupByRewriter(groupByState) {
                @Override
                public IVariable<?> var() {
                    return op.var();
                }
            };
            
            this.groupBy = groupByState.getGroupByClause();

//            this.select = groupByState.getSelectClause();
            
//            this.having = groupByState.getHavingClause();

            // The map is only defined if a GROUP_BY clause was used.
            this.map = groupBy == null ? null
                    : new LinkedHashMap<SolutionGroup, SolutionMultiSet>(
                            op.getInitialCapacity(), op.getLoadFactor());

        }

        /**
         * Add the solution to the multiset for the appropriate group. If we can
         * not compute the GROUP_BY value expressions for a solution, then the
         * solution is dropped.
         * 
         * @param bset
         *            The solution.
         */
        private void accept(final IBindingSet bset) {

            if (groupBy == null || groupBy.length == 0)
                throw new IllegalArgumentException();

            if (bset == null)
                throw new IllegalArgumentException();

            final SolutionGroup s = SolutionGroup.newInstance(groupBy, bset);

            if (s == null) {

                // Drop the solution.

                if (log.isDebugEnabled())
                    log.debug("Dropping solution: " + bset);

                return;

            }

            SolutionMultiSet m = map.get(s);

            if (m == null) {

                map.put(s, m = new SolutionMultiSet());

            }

            // Accept the solution.
            if (log.isTraceEnabled())
                log.trace("Accepting solution: " + bset);

            m.add(bset);

        }

        public Void call() throws Exception {

			final BOpStats stats = context.getStats();

			final IAsynchronousIterator<IBindingSet[]> itr = context
					.getSource();

			final IBlockingBuffer<IBindingSet[]> sink = context.getSink();

			try {

                final List<IBindingSet> accepted = new LinkedList<IBindingSet>();

                int naccepted = 0;

                if (groupBy == null) {

                    /*
                     * Combine all solutions into a single multiset.
                     */
                    final SolutionMultiSet m = new SolutionMultiSet();
                    
                    while (itr.hasNext()) {

                        final IBindingSet[] a = itr.next();

                        stats.chunksIn.increment();
                        stats.unitsIn.add(a.length);

                        for (IBindingSet bset : a) {

                            m.add(bset);

                        }                    
                        
                    }
                    
                    // Compute the aggregate for that group.
                    final IBindingSet bset = aggregate(m.solutions);

                    if (bset != null) {

                        if (log.isDebugEnabled())
                            log.debug("output: solution=" + bset);

                        accepted.add(bset);

                        naccepted++;

                    } else {

                        if (log.isDebugEnabled())
                            log.debug("output : no solution.");
                        
                    }

                } else {

                    /*
                     * Group the solutions.
                     */
                    
                    while (itr.hasNext()) {

                        final IBindingSet[] a = itr.next();

                        stats.chunksIn.increment();
                        stats.unitsIn.add(a.length);

                        for (IBindingSet bset : a) {

                            accept(bset);

                        }

                    }

                    for (Map.Entry<SolutionGroup, SolutionMultiSet> e : map
                            .entrySet()) {

                        final SolutionMultiSet m = e.getValue();

                        // Compute the aggregate for that group.
                        final IBindingSet bset = aggregate(m.solutions);

                        if (bset != null) {
                            
                            if (log.isDebugEnabled())
                                log.debug("output: groupBy=" + e.getKey()
                                        + ", solution=" + bset);

                            accepted.add(bset);

                            naccepted++;
                            
                        } else {
                            
                            if (log.isDebugEnabled())
                                log.debug("output: groupBy=" + e.getKey()
                                        + " : dropped.");
                            
                        }

                    }

                    // discard the map.
                    map.clear();

                }

                /*
                 * Output the aggregated bindings for the accepted solutions.
                 */
                if (naccepted > 0) {

                    final IBindingSet[] b = accepted
                            .toArray(new IBindingSet[naccepted]);

                    sink.add(b);

                    // flush the output.
                    sink.flush();

                }

                // done.
                return null;

            } finally {

                sink.close();

            }

        } // call()

        /**
         * Compute the aggregate solution for a solution multiset (aka a group).
         * 
         * @return The aggregate solution -or- <code>null</code> if the solution
         *         for the group was dropped (type error or violated HAVING
         *         constraint).
         * 
         *         TODO Unit test w/ errors in aggregates or in the value
         *         expressions using those aggregates. Make sure that we do not
         *         drop the group (or fail the query) just because there is an
         *         error with a more local evaluation scope.
         */
        public IBindingSet aggregate(final Iterable<IBindingSet> solutions) {

            if (!solutions.iterator().hasNext()) {
                // Drop empty group.
                return null;
            }

            /**
             * The intermediate solution with all bindings produced when
             * evaluating this solution group. Evaluation begins by binding any
             * bare variables or BINDs in the GROUP_BY clause, followed by
             * evaluating all aggregates, and then finally evaluating the
             * (rewritten) SELECT expressions. The rewritten HAVING clause (if
             * any) may then be then be trivially evaluated. If the solution is
             * not dropped, then only the SELECTed variables are projected out.
             */
            final IBindingSet aggregates = new ListBindingSet();

            /**
             * Propagate GROUP_BY expression onto [aggregates]. 
             */
            if (groupBy != null) {

                // The first solution in the group (must exist since the
                // group was observed).
                final IBindingSet aSolution = solutions.iterator().next();

                for (IValueExpression<?> expr : groupBy) {

                    if (expr instanceof IVariable<?>) {

                        /**
                         * Propagate bare variable used in GROUP_BY clause to
                         * [aggregates].
                         * 
                         * <pre>
                         * GROUP BY ?x
                         * </pre>
                         */

                        final IVariable<?> var = (IVariable<?>) expr;

                        // Note: MUST be a binding for each groupBy var.
                        @SuppressWarnings({ "rawtypes", "unchecked" })
                        final Constant<?> val = new Constant(var.get(aSolution));

                        // Bind on [aggregates].
                        aggregates.set(var, val);

                    } else if (expr instanceof IBind<?>) {

                        /**
                         * Propagate BIND declared by GROUP_BY clause to
                         * [aggregates].
                         * 
                         * <pre>
                         * GROUP BY (2*?y as ?x)
                         * </pre>
                         */

                        final IBind<?> bindExpr = (IBind<?>) expr;

                        // Compute value expression.
                        // Note: MUST be valid since group exists.
                        @SuppressWarnings({ "rawtypes", "unchecked" })
                        final Constant<?> val = new Constant(
                                bindExpr.get(aSolution));

                        // Variable to be projected out by SELECT.
                        final IVariable<?> ovar = ((IBind<?>) expr).getVar();

                        // Bind on [aggregates].
                        aggregates.set(ovar, val);

                    }

                } // next GROUP_BY value expression

            } // if(groupBy != null)

            /**
             * Compute the aggregates.
             * 
             * TODO This can be further optimized by computing the column
             * projections of the different value expressions exactly once and
             * then applying the aggregation functions to those column
             * projections. As long as we adhere to the dependency ordering
             * among those aggregates, we can compute them all in a single pass
             * over the column projections.
             * 
             * TODO DISTINCT projections of columns projections can be modeled
             * in a bunch of different ways, but if we need the original column
             * projection as well as the DISTINCT of that column projection then
             * it makes sense to either form the DISTINCT projection while
             * building the column projection or as an after action.
             */
            {

                final Iterator<Map.Entry<IAggregate<?>, IVariable<?>>> itr = rewrite
                        .getAggExpr().entrySet().iterator();
                while (itr.hasNext()) {
                    final Map.Entry<IAggregate<?>, IVariable<?>> e = itr.next();
                    // Aggregate.
                    final IConstant<?> c = doAggregate(e.getKey(), solutions);
                    if (c != null) {
                        // bind the result.
                        aggregates.set(e.getValue(), c);
                    }
                }
                if (log.isTraceEnabled())
                    log.trace("aggregates: " + aggregates);
                
            }

            // Evaluate SELECT expressions.
            for (IValueExpression<?> expr : rewrite.getSelect2()) {

                /*
                 * FIXME This is really quite a hack, turning an
                 * IllegalArgumentException which we presume is coming out of
                 * new Constant(null) into an (implicit) SPARQL type error so we
                 * can drop the binding for this SELECT expression. (Note that
                 * we are not trying to drop the entire group!)
                 */
                try {
                    expr.get(aggregates);
                } catch (IllegalArgumentException ex) {
                    if (log.isInfoEnabled())
                        log.info("will not bind solution for aggregate due to error: expr="
                                + expr + ", cause=" + ex);
                    continue;
                }

            }

            /*
             * Verify optional constraint(s).
             * 
             * TODO This could be done before fully computing the aggregates as
             * we only need to have on hand those computed aggregates on which
             * the HAVING clause depends.
             */
            {
                final boolean drop;
                final IConstraint[] having2 = rewrite.getHaving2();
                if (having2 != null
                        && !BOpUtility.isConsistent(having2, aggregates)) {
                    // drop this solution.
                    drop = true;
                } else {
                    drop = false;
                }

                if (log.isInfoEnabled())
                    log.info((drop ? "drop" : "keep") + " : " + aggregates);

                if (drop) {

                    // Drop this solution.
                    return null;

                }
            }

            // project out only selected variables.
            final IBindingSet out = aggregates.copy(groupByState
                    .getSelectVars().toArray(new IVariable[0]));

            return out;

        }

    } // GroupByTask

    /**
     * Apply the value expression to each solution in the group.
     * 
     * TODO It is a bit wasteful to compute COUNT() by iterating when we could
     * just check the size of the solution multiset.
     */
    private static IConstant<?> doAggregate(final IAggregate<?> a,
            final Iterable<IBindingSet> solutions) {

        try {

            final IConstant<?> ret;
            if (a.isWildcard() && a.isDistinct()) {
                /*
                 * For a wildcard we basically need to operate on solution
                 * multisets. For example, COUNT(*) is the size of the solution
                 * multiset (aka group).
                 */
                // Set used to impose DISTINCT on the solution multiset.
                final LinkedHashSet<IBindingSet> set = new LinkedHashSet<IBindingSet>();
                a.reset();
                for (IBindingSet bset : solutions) {
                    if (set.add(bset)) {
                        // aggregate iff this is a new result.
                        a.get(bset);
                    }
                }
                ret = new Constant(a.done());
            } else if (a.isDistinct()) {
                /*
                 * Apply aggregate function only to the distinct values which
                 * it's inner value expression takes on.
                 */
                // Set used to impose "DISTINCT".
                final Set<Object> set = new LinkedHashSet<Object>();
                // The inner value expression.
                final IValueExpression<?> innerExpr = a.getExpr();
                a.reset();
                for (IBindingSet bset : solutions) {
                    final Object val = innerExpr.get(bset);
                    if (set.add(val)) {
                        // aggregate iff this is a new result.
                        a.get(bset);
                    }
                }
                ret = new Constant(a.done());
            } else {
                a.reset();
                for (IBindingSet bset : solutions) {
                    a.get(bset);
                }
                ret = new Constant(a.done());
            }
            return ret;
        } catch (Throwable t) {

            if (InnerCause.isInnerCause(t, SparqlTypeErrorException.class)) {

                // trap the type error and filter out the solution
                if (log.isInfoEnabled())
                    log.info("discarding solution due to type error: " + t);

                // No binding.
                return null;

            }

            throw new RuntimeException(t);

        }

    }

}
