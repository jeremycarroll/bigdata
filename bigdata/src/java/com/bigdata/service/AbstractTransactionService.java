/**

Copyright (C) SYSTAP, LLC 2006-2007.  All rights reserved.

Contact:
     SYSTAP, LLC
     4501 Tower Road
     Greensboro, NC 27410
     licenses@bigdata.com

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; version 2 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/
/*
 * Created on Mar 15, 2007
 */

package com.bigdata.service;

import java.io.IOException;
import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.Properties;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.locks.ReentrantLock;

import org.apache.log4j.Logger;

import com.bigdata.concurrent.LockManager;
import com.bigdata.journal.AbstractJournal;
import com.bigdata.journal.ITransactionService;
import com.bigdata.journal.ITx;
import com.bigdata.journal.Journal;
import com.bigdata.journal.RunState;
import com.bigdata.journal.TimestampUtility;
import com.bigdata.journal.ValidationError;
import com.bigdata.util.InnerCause;

/**
 * Centalized transaction manager service. In response to a client request, the
 * transaction manager will distribute prepare/commit or abort operations to all
 * data services on which writes were made by a transaction. The transaction
 * manager also provides global timestamps required for non-transactional commit
 * points and various other purposes.
 * 
 * @author <a href="mailto:thompsonbry@users.sourceforge.net">Bryan Thompson</a>
 * @version $Id$
 * 
 * @todo The transaction server should make sure that time does not go backwards
 *       when it starts up (with respect to the last time that it issued). Note
 *       that {@link AbstractJournal#commit(long)} already protects against this
 *       problem.
 * 
 * @todo failover. the service instances will need to track active/committed
 *       transactions, complain if their clocks get out of alignment, and refuse
 *       to generate a timestamp that would go backwards when compared to the
 *       timestamp generated by the last master service.
 * 
 * @todo Read-only transactions do not have client-side state and clients are
 *       NOT notified when read-only transactions complete. However, a
 *       standalone {@link Journal} must keep running during shutdown until its
 *       read-only transactions complete. It achieves this goal using a simple
 *       counter of the #of open read-only transactions.
 */
abstract public class AbstractTransactionService extends TimestampService implements
        ITransactionService {

    /**
     * Logger.
     */
    protected static final Logger log = Logger.getLogger(AbstractTransactionService.class);

    protected static final boolean INFO = log.isInfoEnabled();

    protected static final boolean DEBUG = log.isDebugEnabled();
    
    /**
     * Options understood by this service.
     * 
     * @author <a href="mailto:thompsonbry@users.sourceforge.net">Bryan Thompson</a>
     * @version $Id$
     */
    public interface Options extends TimestampService.Options {
        
    }
    
    /**
     * If the transaction is read-only and a write operation was requested.
     */
    protected static final transient String ERR_READ_ONLY = "Read-only";
    
    /**
     * If the transaction is not known to this service.
     */
    protected static final transient String ERR_NO_SUCH = "Unknown transaction";
    
    /**
     * If a transaction is no longer active.
     */
    protected static final transient String ERR_NOT_ACTIVE = "Not active";
    
    /**
     * A hash map containing all active transactions. A transaction that is
     * preparing will remain in this collection until it has completed (aborted
     * or committed).
     * 
     * @todo config param for the initial capacity of the map.
     * @todo config for the concurrency rating of the map.
     */
    final private ConcurrentHashMap<Long, TxState> activeTx = new ConcurrentHashMap<Long, TxState>();

    /**
     * The #of open transactions in any {@link RunState}.
     */
    final public int getActiveCount() {
        
        return activeTx.size();
        
    }
    
    public AbstractTransactionService(final Properties properties) {
        
        super(properties);
        
    }

    /**
     * @todo We will need to distinguish more run states since some operations
     *       must continue during both {@link #shutdown()} and
     *       {@link #shutdownNow()}.
     */
    protected void assertOpen() {

        if (!isOpen())
            throw new IllegalStateException();

    }
    
    /**
     * Polite shutdown. New transactions will not start. This method will block
     * until existing transactions are complete (either aborted or committed).
     * 
     * FIXME implement shutdown.
     * 
     * @todo Support a federation shutdown protocol. The transaction manager is
     *       notified that the federation will shutdown. At that point the
     *       transaction manager should refuse to start new transactions, but
     *       MUST continue to issue timestamps. Once no more transactions are
     *       active, a shutdown notice should be broadcast to the data services.
     *       Once the data services are down, the metadata service and the load
     *       balancer may be shutdown as well. When the transaction manager
     *       itself shuts down it must save the last assigned transaction commit
     *       time so that it can verify that time does not go backwards on
     *       restart.
     */
    synchronized public void shutdown() {
        
        super.shutdown();
        
    }
    
    /**
     * Fast shutdown (not immediate since it must abort active transactions).
     * <p>
     * New transactions will not start and active transactions will be aborted.
     * Transactions which are in the middle of a commit will execute normally
     * and may result in either commits or aborts (if the commit fails, e.g.,
     * due to validation errors).
     * 
     * FIXME implement shutdownNow
     */
    synchronized public void shutdownNow() {

//        commitService.shutdownNow();

        super.shutdownNow();
        
    }

    /**
     * Immediatly shutdown the service and destroy any persistent state
     * associated with the service.
     */
    synchronized public void destroy() {
        
        shutdownNow();
        
    }
    
    /**
     * Note: There is an upper bound of one read-write transaction that may be
     * created per millisecond (the resolution of {@link #nextTimestamp()}) and
     * requests for new read-write transactions contend with other requests for
     * {@link #nextTimestamp()}.
     * <p>
     * Note: The transaction service will refuse to start new transactions whose
     * timestamps are LTE to {@link #getReleaseTime()}.
     */
    public long newTx(final long timestamp) {

        /*
         * Note: It may be possible to increase the concurrency of this
         * operation. Many cases do not allow contention since they will just
         * use the value returned by nextTimestamp(), which is always distinct.
         * Those cases which do allow contention involve search for a start time
         * that can read from a specific commit point. Even then we may be able
         * to reduce contention using atomic operations on [activeTx], e.g.,
         * putIfAbsent().
         */

        synchronized (newTxLock) {

            final long tx = assignTransactionIdentifier(timestamp);

            activateTx(new TxState(tx));
            
            return tx;
            
        }

    }

    private final Object newTxLock = new Object();

    /** #of transactions started. */
    private long startCount = 0L;

    /** #of transactions aborted. */
    private long abortCount = 0L;

    /** #of transactions committed. */
    private long commitCount = 0L;

    /** #of active read-write transactions. */
    private final AtomicLong readWriteActiveCount = new AtomicLong(0L);

    /** #of active read-only transactions. */
    private final AtomicLong readOnlyActiveCount = new AtomicLong(0L);

    /** #of transaction started. */
    public long getStartCount() {
        
        return startCount;
        
    }
    
    /** #of transaction aborted. */
    public long getAbortCount() {
        
        return abortCount;
        
    }
    
    /** #of transaction committed. */
    public long getCommitCount() {
        
        return commitCount;
        
    }
    
    public long getReadOnlyActiveCount() {
        
        return readOnlyActiveCount.get();
        
    }
    
    public long getReadWriteActiveCount() {
        
        return readWriteActiveCount.get();
        
    }
    
    /**
     * Return the release time (the timestamp whose historical data MAY be
     * released).
     */
    protected abstract long getReleaseTime();
    
    /**
     * Adds the transaction from to the local tables.
     * 
     * @param state
     *            The transaction.
     */
    protected void activateTx(final TxState state) {

        if (state == null)
            throw new IllegalArgumentException();

        state.lock.lock();

        try {
        
            if (!state.isActive())
                throw new IllegalArgumentException();
            
            activeTx.put(state.tx, state);

            startCount++;

            if(state.isReadOnly()) {
                
                readOnlyActiveCount.incrementAndGet();
                
            } else {
                
                readWriteActiveCount.incrementAndGet();
                
            }
            
        } finally {
            
            state.lock.unlock();
            
        }
        
    }
    
    /**
     * Removes the transaction from the local tables.
     * 
     * @param state
     *            The transaction.
     */
    protected void deactivateTx(final TxState state) {
        
        if (state == null)
            throw new IllegalArgumentException();

        state.lock.lock();

        try {
        
            if (!state.isComplete())
                throw new IllegalArgumentException();
            
            if(state.isAborted()) {
                
                abortCount++;
                
            } else {
                
                commitCount++;
                
            }
            
            if(state.isReadOnly()) {
                
                readOnlyActiveCount.decrementAndGet();
                
            } else {
                
                readWriteActiveCount.decrementAndGet();
                
            }

            if (activeTx.remove(state.tx) == null) {
                
                log.warn("Transaction not in table: " + state);
                
            }
            
        } finally {
            
            state.lock.unlock();
            
        }
                
        updateReleaseTime(state.tx);
        
    }
    
    /**
     * Assign a transaction identifier for a new transaction.
     * 
     * @param timestamp
     *            The timestamp.
     *            
     * @return The assigned transaction identifier.
     */
    protected long assignTransactionIdentifier(final long timestamp) {
        
        if (timestamp == ITx.UNISOLATED) {

            /*
             * When timestamp is ZERO (0L), this simply returns the next
             * distinct timestamp (with its sign bit flipped).
             * 
             * Note: This is guarenteed to be a valid start time since it is LT
             * the next possible commit point for the database.
             * 
             * Note: When we validate, we will read from [-startTime] and the
             * journal will identify the 1st commit point LTE [-startTime],
             * which will be the most recent commit point on the database as of
             * the moment when we assigned this transaction identifier.
             */

            return -nextTimestamp();

        }

        final long lastCommitTime = lastCommitTime();

        if (timestamp > lastCommitTime) {

            /*
             * You can't request a historical read for a timestamp which has not
             * yet been issued by this service!
             */
            
            throw new IllegalStateException(
                    "Timestamp is in the future: timestamp=" + timestamp
                            + ", lastCommitTime=" + lastCommitTime);

        } else if (timestamp == lastCommitTime) {
            
            /*
             * Special case. We just return the next timestamp.
             * 
             * Note: This is equivalent to a request using the symbolic constant
             * READ_COMMITTED.
             */
            
            return nextTimestamp();
            
        }
        
        if (timestamp == ITx.READ_COMMITTED) {

            /*
             * This is a symbolic shorthand for a read-only transaction that
             * will read from the most recent commit point on the database.
             * 
             * Note: Once again we can just issue a timestamp since it will be
             * GT lastCommitTime.
             * 
             * Note: If [lastCommitTime == 0], we will still issue the next
             * timestamp.
             */

            return nextTimestamp();
            
        }
        
        final long releaseTime = getReleaseTime();
        
        if (timestamp <= releaseTime) {

            /*
             * This exception is thrown if there is an attempt to start a new
             * transaction that would read from historical data which has been
             * released. While the data MIGHT still be around, there is no way
             * to assert a read lock for that data since the releaseTime is
             * already in the future.
             */
            
            throw new IllegalStateException(
                    "Timestamp is less than the release time: timestamp="
                            + timestamp + ", releaseTime=" + releaseTime);
            
        }
        
        return getStartTime(timestamp);

    }

    /**
     * Assign a distinct timestamp to a historical read that will read from the
     * commit point identified by the specified timestamp.
     * <p>
     * Note: Under some circumstances the assignment of a read-only transaction
     * identifier must be delayed until a distinct timestamp becomes available
     * between the designed start time and the next commit point.
     * 
     * @param timestamp
     *            The timestamp (identifies the desired commit point).
     * 
     * @return A distinct timestamp not in use by any transaction that will read
     *         from the same commit point.
     */
    protected long getStartTime(final long timestamp) {

//        synchronized(commitTimeIndex) {
        
            /*
             * Find the commit time from which the tx will read (largest
             * commitTime LTE timestamp).
             */
            final long commitTime = findCommitTime(timestamp);
            
            if (commitTime == -1L) {

                /*
                 * @todo I believe that this can only arise when there are no
                 * commit points in the log.
                 */
                throw new RuntimeException(
                        "No data for that commit time: timestamp=" + timestamp);
                
            }

            /*
             * The commit time for the successor of that commit point (GT).
             */
            final long nextCommitTime = findNextCommitTime(commitTime);

            if (nextCommitTime == -1L) {

                /*
                 * Note: If there is no successor of the desired commit point
                 * then we can just return the next timestamp. It is guarenteed
                 * to be GT the desired commit time and LT the next commit
                 * point. [Note: this case is in fact handled above so you
                 * should not get here.]
                 */

                return nextTimestamp();

            }

            // Find a valid, unused timestamp.
            return findUnusedTimestamp(commitTime, nextCommitTime);

//        }

    }

    /**
     * Find the commit time from which the tx will read (largest commitTime LTE
     * timestamp).
     * 
     * @param timestamp
     *            The timestamp.
     * 
     * @return The commit time and -1L if there is no such commit time.
     */
    protected abstract long findCommitTime(long timestamp);

    /**
     * Return the commit time for the successor of that commit point have the
     * specified timestamp (a commit time strictly GT the given value).
     * 
     * @param commitTime
     *            The probe.
     * @return The successor or -1L iff the is no successor for that commit
     *         time.
     */
    protected abstract long findNextCommitTime(long commitTime);
    
    /**
     * Find a valid, unused timestamp.
     * <p>
     * Note: Any timestamp in the half-open range [commitTime:nextCommitTime)
     * MAY be assigned as all such timestamps will read from the commit point
     * associated with [commitTime].
     * 
     * @param commitTime
     *            The commit time for the commit point on which the tx will read
     *            (this must be the exact timestamp associated with the desired
     *            commit point).
     * @param nextCommitTime
     *            The commit time for the successor of that commit point.
     */
    protected long findUnusedTimestamp(final long commitTime,
            final long nextCommitTime) {

        for (long t = commitTime; t < nextCommitTime; t++) {

            if (activeTx.containsKey(t)) {

                /*
                 * @todo We could grap the timestamp using an atomic putIfAbsent
                 * and a special value and the replace the value with the
                 * desired one (or just construct the TxState object each time
                 * and discard it if the map contains that key).  This might
                 * let us increase concurrency for newTx().
                 */
                
                continue;
                
            }
            
            return t;
            
        }
        
        /*
         * @todo Wait for a tx to end in the desired half-open range and then
         * assign it immediately to the first request for that half-open range.
         */

        throw new RuntimeException("No timestamp available: commitTime="
                + commitTime + ", nextCommitTime=" + nextCommitTime);
        
    }
    
    /**
     * Note: Declared abstract so that we can hide the {@link IOException}.
     */
    abstract public long lastCommitTime();

    /**
     * Implementation must abort the tx on the journal (standalone) or on each
     * data service (federation) on which it has written.
     * <p>
     * Pre-conditions:
     * <ol>
     * <li>The transaction is {@link RunState#Active}; and</li>
     * <li>The caller holds the {@link TxState#lock}.</li>
     * </ol>
     * <p>
     * Post-conditions:
     * <ol>
     * <li>The transaction is {@link RunState#Aborted}; and</li>
     * <li>The transaction write set has been discarded by each {@link Journal}
     * or {@link IDataService} or which it has written (applicable for
     * read-write transactions only).</li>
     * </ol>
     * <p>
     * This method SHOULD NOT throw any exceptions.
     * 
     * @param state
     *            The transaction state as maintained by the transaction server.
     */
    abstract protected void abortImpl(final TxState state);

    /**
     * Implementation must either single-phase commit (standalone journal or a
     * transaction that only writes on a single data service) or 2-/3-phase
     * commit (distributed transaction running on a federation).
     * <p>
     * Pre-conditions:
     * <ol>
     * <li>The transaction is {@link RunState#Active}; and</li>
     * <li>The caller holds the {@link TxState#lock}.</li>
     * </ol>
     * <p>
     * Post-conditions (success for read-only transaction or a read-write
     * transaction with an empty write set):
     * <ol>
     * <li>The transaction is {@link RunState#Committed}; and</li>
     * <li>The returned <i>commitTime</i> is ZERO (0L).</li>
     * </ol>
     * <p>
     * Post-conditions (success for read-write transaction with a non-empty
     * write set):
     * <ol>
     * <li>The transaction is {@link RunState#Committed};</li>
     * <li>The transaction write set has been made restart-safe by each
     * {@link Journal} or {@link IDataService} or which it has written
     * (applicable for read-write transactions only); and</li>
     * <li>The application can read exactly the data written by the transaction
     * from the commit point identified by the returned <i>commitTime</i>.</li>
     * </ol>
     * <p>
     * Post-conditions (failure):
     * <ol>
     * <li>The transaction is {@link RunState#Aborted}; and</li>
     * <li>The transaction write set has been discarded by each {@link Journal}
     * or {@link IDataService} or which it has written (applicable for
     * read-write transactions only).</li>
     * </ol>
     * 
     * @param tx
     *            The transaction identifier.
     * 
     * @return The commit time for the transaction -or- ZERO (0L) if the
     *         transaction was read-only or had an empty write set.
     * 
     * @throws Exception
     *             if something else goes wrong. This will be (or will wrap) a
     *             {@link ValidationError} if validation fails.
     */
    abstract protected long commitImpl(final TxState state) throws Exception;

    /**
     * FIXME Remove the transaction entry in the ordered set of running
     * transactions. If the transaction was the lowest entry in that ordered
     * set, then update the releaseTime to the now lowest member of that set.
     * Note that the ordered set only contains the absolute value of the
     * transaction identifers! [this suggests that we need a BTree for the
     * activeTx, which should be leveraged by
     * {@link #findUnusedTimestamp(long, long)} so that it can constraint its
     * search within the half-open interval.]
     * 
     * FIXME The head of the log must be truncated whenever we advance the
     * releaseTime (that is, we always remove an entry when a tx completes and
     * if the entry is the head of the log then it is the earliest tx and we
     * also advance the release time).
     * 
     * @todo edge case when the set is empty sets the releaseTime to zero, but
     *       minReleaseAge will prevent us from really releasing all state in
     *       the db.
     * 
     * @param tx
     *            The transaction identifier.
     * 
     * @todo periodically we should compare {@link #activeTx} with the data
     *       structure used to track the earliest running tx. or perhaps they
     *       can be basically one and the same.
     */
    protected void updateReleaseTime(final long tx) {
        
    }
    
    /**
     * Abort the transaction (asynchronous).
     */
    public void abort(final long tx) {

        final TxState state = activeTx.get(tx);

        if (state == null)
            throw new IllegalStateException(ERR_NO_SUCH);
        
        state.lock.lock();

        try {

            if (!state.isActive()) {

                throw new IllegalStateException(ERR_NOT_ACTIVE);

            }

            abortImpl(state);

            assert state.isAborted();
            
            deactivateTx(state);
            
        } finally {
            
            state.lock.unlock();

        }

    }

    public long commit(final long tx) throws ValidationError {

        final TxState state = activeTx.get(tx);

        if (state == null) {

            throw new IllegalStateException(ERR_NO_SUCH);

        }

        state.lock.lock();

        try {

            if (!state.isActive()) {

                throw new IllegalStateException(ERR_NOT_ACTIVE);

            }

            try {

                final long commitTime = commitImpl(state);

                assert state.isCommitted() : "tx="+state;

                return commitTime;

            } catch (Throwable t2) {

                log.error(t2.getMessage(),t2);// @todo remove.
                
                assert state.isAborted() : "ex=" + t2 + ", tx=" + state;

                if (InnerCause.isInnerCause(t2, ValidationError.class)) {

                    throw new ValidationError();

                }
                
                log.error(t2.getMessage(),t2);

                throw new RuntimeException(t2);

            }

        } finally {

            deactivateTx(state);

            state.lock.unlock();
            
        }

    }

    /**
     * Note: Only those {@link DataService}s on which a read-write transaction
     * has started will participate in the commit. If there is only a single
     * such {@link IDataService}, then a single-phase commit will be used.
     * Otherwise a distributed transaction commit protocol will be used.
     * <p>
     * Note: The commits requests are placed into a partial order by sorting the
     * total set of resources which the transaction declares (via this method)
     * across all operations executed by the transaction and then contending for
     * locks on the named resources using a {@link LockManager}. This is handled
     * by the {@link DistributedTransactionService}.
     */
    public void declareResources(final long tx, final UUID dataServiceUUID,
            final String[] resource) throws IllegalStateException {

        if (dataServiceUUID == null)
            throw new IllegalArgumentException();

        if (resource == null)
            throw new IllegalArgumentException();
        
        final TxState state = activeTx.get(tx);

        if (state == null) {

            throw new IllegalStateException(ERR_NO_SUCH);

        }

        state.lock.lock();

        try {

            if (state.isReadOnly()) {

                throw new IllegalStateException(ERR_READ_ONLY);

            }

            if (!state.isActive()) {

                throw new IllegalStateException(ERR_NOT_ACTIVE);

            }

            state.declareResources(dataServiceUUID, resource);
            
        } finally {

            state.lock.unlock();

        }

    }

    /**
     * Transaction state.
     * 
     * @author <a href="mailto:thompsonbry@users.sourceforge.net">Bryan Thompson</a>
     * @version $Id$
     */
    protected class TxState {

        /**
         * The transaction identifier.
         */
        public final long tx;
        
        /**
         * <code>true</code> iff the transaction is read-only.
         */
        public final boolean readOnly;

        /**
         * The run state of the transaction (only accessible while you are
         * holding the {@link #lock}.
         * 
         * @todo make private and use {@link #setRunState(RunState)}
         */
        protected RunState runState = RunState.Active;
        
        /**
         * Change the {@link RunState}.
         * 
         * @param newval
         *            The new {@link RunState}.
         * 
         * @throws IllegalArgumentException
         *             if the argument is <code>null</code>.
         * @throws IllegalStateException
         *             if the state transition is not allowed.
         * 
         * @see RunState#isTransitionAllowed(RunState)
         */
        public void setRunState(final RunState newval) {

            if (!lock.isHeldByCurrentThread())
                throw new IllegalMonitorStateException();

            if (newval == null)
                throw new IllegalArgumentException();
            
            if (!runState.isTransitionAllowed(newval)) {

                throw new IllegalStateException("runState=" + runState
                        + ", newValue=" + newval);

            }

            this.runState = newval;
            
        }
        
        /**
         * The commit time assigned to a distributed read-write transaction
         * during the commit protocol and otherwise ZERO (0L).
         */
        private long commitTime = 0L;
        
        /**
         * The commit time assigned to a distributed read-write transaction
         * during the commit protocol.
         * 
         * @return The assigned commit time.
         * 
         * @throws IllegalStateException
         *             if the commit time has not been assigned.
         */
        public long getCommitTime() {
            
            if (!lock.isHeldByCurrentThread()) {

                throw new IllegalMonitorStateException();
                
            }
            
            if (commitTime == 0L) {

                throw new IllegalStateException();
                
            }
            
            return commitTime;
            
        }

        /**
         * Sets the assigned commit time.
         * 
         * @param commitTime
         *            The assigned commit time.
         */
        protected void setCommitTime(final long commitTime) {

            if (!lock.isHeldByCurrentThread()) {

                throw new IllegalMonitorStateException();
                
            }
            
            if (commitTime == 0L) {
                
                throw new IllegalArgumentException();
                
            }

            if (this.commitTime != 0L) {
                
                throw new IllegalStateException();
                
            }
            
            this.commitTime = commitTime;

        }
        
        /**
         * Barrier used to await the
         * {@link ITransactionService#prepared(long, UUID)} messages during a
         * distributed read-write transaction commit.
         */
        protected CyclicBarrier preparedBarrier = null;

        /**
         * Barrier used to await the
         * {@link ITransactionService#committed(long, UUID)} messages during a
         * distributed read-write transaction commit.
         */
        protected CyclicBarrier committedBarrier = null;

        /**
         * The set of {@link DataService}s on which a read-write transaction
         * has been started and <code>null</code> if this is not a read-write
         * transaction.
         * <p>
         * Note: We only track this information for a distributed database.
         */
        private final Set<UUID/* dataService */> dataServices;

        /**
         * The set of named resources that the transaction has declared across
         * all {@link IDataService}s on which it has written and
         * <code>null</code> if this is not a read-write transaction.
         * <p>
         * Note: We only track this information for a distributed database.
         */
        private final Set<String/* name */> resources;

        /**
         * Return the resources declared by the transaction.
         */
        public String[] getResources() {

            if (!lock.isHeldByCurrentThread())
                throw new IllegalMonitorStateException();

            if (resources == null)
                return new String[] {};

            return resources.toArray(new String[] {});
            
        }
        
        /**
         * Return <code>true</code> iff the dataService identified by the
         * {@link UUID} is one on which this transaction has been started.
         * 
         * @param dataServiceUUID
         *            The {@link UUID} identifying an {@link IDataService}.
         * 
         * @return <code>true</code> if this transaction has been started on
         *         that {@link IDataService}. <code>false</code> for
         *         read-only transactions.
         */
        public boolean isStartedOn(final UUID dataServiceUUID) {
            
            if(!lock.isHeldByCurrentThread())
                throw new IllegalMonitorStateException();

            if (dataServiceUUID == null)
                throw new IllegalArgumentException();
            
            if (dataServices == null)
                return false;

            return dataServices.contains(dataServiceUUID);
            
        }
        
        /**
         * The set of {@link DataService}s on which the transaction has
         * written.
         * 
         * @throws IllegalStateException
         *             if not a read-write transaction.
         */
        protected UUID[] getDataServiceUUIDs() {

            if(!lock.isHeldByCurrentThread())
                throw new IllegalMonitorStateException();
            
            if (dataServices == null)
                throw new IllegalStateException();
            
            return dataServices.toArray(new UUID[] {});
            
        }
        
        /**
         * A per-transaction lock used to serialize operations on a given
         * transaction. You need to hold this lock for most of the operations on
         * this class, including any access to the {@link RunState}.
         */
        final protected ReentrantLock lock = new ReentrantLock();
        
        protected TxState(final long tx) {
            
            if (tx == ITx.UNISOLATED)
                throw new IllegalArgumentException();

            if (tx == ITx.READ_COMMITTED)
                throw new IllegalArgumentException();
            
            this.tx = tx;
            
            this.readOnly = TimestampUtility.isReadOnly(tx);
                       
            // pre-compute the hash code for the transaction.
            this.hashCode = Long.valueOf(tx).hashCode();

            this.dataServices = readOnly ? null : new LinkedHashSet<UUID>();

            this.resources = readOnly ? null : new LinkedHashSet<String>();
            
        }

        /**
         * The hash code is based on the {@link #getStartTimestamp()}.
         */
        final public int hashCode() {
            
            return hashCode;

        }

        private final int hashCode;

        /**
         * True iff they are the same object or have the same start timestamp.
         * 
         * @param o
         *            Another transaction object.
         */
        final public boolean equals(ITx o) {

            return this == o || tx == o.getStartTimestamp();

        }

        /**
         * Declares resources on a data service instance on which the
         * transaction will write.
         * 
         * @param dataService
         *            The data service identifier.
         * @param resource
         *            An array of named resources on the data service on which
         *            the transaction will write (or at least for which it
         *            requires an exclusive write lock).
         * 
         * @throws IllegalStateException
         *             if the transaction is read-only.
         * @throws IllegalStateException
         *             if the transaction is not active.
         */
        final public void declareResources(final UUID dataService,
                final String[] resource) {

            if (dataService == null)
                throw new IllegalArgumentException();
            
            if (resource == null)
                throw new IllegalArgumentException();
            
            if (!lock.isHeldByCurrentThread())
                throw new IllegalMonitorStateException();

            if (readOnly)
                throw new IllegalStateException(ERR_READ_ONLY);

            if (!isActive())
                throw new IllegalStateException(ERR_NOT_ACTIVE);

            dataServices.add(dataService);
            
            resources.addAll(Arrays.asList(resource));
            
            if (INFO)
                log.info("dataService=" + dataService + ", resource="
                        + resource);

        }

//        /**
//         * Return <code>true</code> if the transaction is read-only or if a
//         * read-write transaction has not been started on any
//         * {@link IDataService}s.
//         * <p>
//         * <strong>WARNING: This method should only be used for distributed
//         * databases. It will always report [false] for a standalone database
//         * since
//         * {@link ITransactionService#declareResources(long, UUID, String[])} is
//         * not invoked for a standalone database!</strong>
//         */
//        final public boolean isEmptyWriteSet() {
//
//            if(!lock.isHeldByCurrentThread())
//                throw new IllegalMonitorStateException();
//
//            return readOnly || dataServices.isEmpty();
//
//        }

        /**
         * Return the #of {@link IDataService}s on which a read-write
         * transaction has executed an operation.
         * 
         * @return The #of {@link IDataService}.
         * 
         * @throws IllegalStateException
         *             if the transaction is read-only.
         * @throws IllegalMonitorStateException
         *             if the caller does not hold the lock.
         */
        final public int getDataServiceCount() {
            
            if(!lock.isHeldByCurrentThread())
                throw new IllegalMonitorStateException();

            if(readOnly)
                throw new IllegalStateException(ERR_READ_ONLY);
            
            return dataServices.size();

        }
        
        /**
         * Return <code>true</code> iff a read-write transaction has started on
         * more than one {@link IDataService}.
         */
        final boolean isDistributedTx() {

            if(!lock.isHeldByCurrentThread())
                throw new IllegalMonitorStateException();

            return !readOnly && dataServices.size() > 1;

        }

        /**
         * Returns a string representation of the transaction state.
         * 
         * @todo more details here, but it must all be safe w/o a lock.
         */
        final public String toString() {

//            return Long.toString(tx);
            
            return "Tx={tx=" + tx + ",readOnly=" + readOnly + ",runState="
                    + runState + "}";

        }

        final public boolean isReadOnly() {

            return readOnly;

        }

        final public boolean isActive() {

            if(!lock.isHeldByCurrentThread())
                throw new IllegalMonitorStateException();

            return runState == RunState.Active;

        }

        final public boolean isPrepared() {

            if(!lock.isHeldByCurrentThread())
                throw new IllegalMonitorStateException();

            return runState == RunState.Prepared;

        }

        final public boolean isComplete() {

            if(!lock.isHeldByCurrentThread())
                throw new IllegalMonitorStateException();

            return runState == RunState.Committed
                    || runState == RunState.Aborted;

        }

        final public boolean isCommitted() {

            if(!lock.isHeldByCurrentThread())
                throw new IllegalMonitorStateException();

            return runState == RunState.Committed;

        }

        final public boolean isAborted() {

            if(!lock.isHeldByCurrentThread())
                throw new IllegalMonitorStateException();

            return runState == RunState.Aborted;

        }

    }

    /** NOP */
    @Override
    public AbstractTransactionService start() {
        
        return this;
        
    }

    @Override
    public Class getServiceIface() {

        return ITransactionService.class;
        
    }
    
}
