package com.bigdata.service.mapReduce;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import com.bigdata.btree.KeyBuilder;
import com.bigdata.btree.UnicodeKeyBuilder;
import com.bigdata.io.DataOutputBuffer;

/**
 * Abstract base class for {@link IMapTask}s.
 * <p>
 * Note: The presumption is that there is a distinct instance of the map
 * task for each task executed and that each task is executed within a
 * single-threaded environment.
 * 
 * @author <a href="mailto:thompsonbry@users.sourceforge.net">Bryan Thompson</a>
 * @version $Id$
 */
abstract public class AbstractMapTask implements IMapTask {

    protected final UUID uuid;
    protected final int nreduce;
    protected final IHashFunction hashFunction;

    private final List tuples = new ArrayList<Tuple>(1000);
    private final int[] histogram;

    /**
     * @param uuid
     *            The UUID of the map task. This MUST be the same UUID each
     *            time if a map task is re-executed for a given input. The
     *            UUID (together with the tuple counter) is used to generate
     *            a key that makes the map operation "retry safe". That is,
     *            the operation may be executed one or more times and the
     *            result will be the same. This guarentee arises because the
     *            values for identical keys are overwritten during the
     *            reduce operation.
     * @param nreduce
     *            The #of reduce tasks that are being feed by this map task.
     * @param hashFunction
     *            The hash function used to hash partition the tuples
     *            generated by the map task into the input sink for each of
     *            the reduce tasks.
     */
    protected AbstractMapTask(UUID uuid, Integer nreduce, IHashFunction hashFunction) {
        
        this.uuid = uuid;
        
        this.nreduce = nreduce;
        
        this.hashFunction = hashFunction;

        this.histogram = new int[nreduce];
        
    }

    public UUID getUUID() {
        
        return uuid;
        
    }
    
    /**
     * Return the tuples.
     * 
     * @return
     */
    public Tuple[] getTuples() {
    
        int ntuples = tuples.size();
        
        return (Tuple[]) tuples.toArray(new Tuple[ntuples]);
        
    }

    /**
     * The {@link KeyBuilder} MUST be used by the {@link IMapTask} so that
     * the generated keys will have a total ordering determined by their
     * interpretation as an <em>unsigned</em> byte[].
     * 
     * @todo does not always have to support unicode
     * @todo could configure the buffer size for some tasks.
     * @todo could choose the collation sequence for unicode.
     */
    protected final KeyBuilder keyBuilder = new UnicodeKeyBuilder();

    /**
     * The values may be formatted using this utility class. The basic
     * pattern is:
     * 
     * <pre>
     * valBuilder.reset().append(foo).toByteArray();
     * </pre>
     */
    protected final DataOutputBuffer valBuilder = new DataOutputBuffer();

    /**
     * The #of tuples written by the task.
     */
    public int getTupleCount() {

        return tuples.size();

    }

    /**
     * Forms a unique key using the data already in {@link #keyBuilder} and
     * appending the task UUID and the int32 tuple counter and then invokes
     * {@link #output(byte[], byte[])} to output the key-value pair. The
     * resulting key preserves the key order, groups all keys with the same
     * value for the same map task, and finally distinguishes individual
     * key-value pairs using the tuple counter.
     * 
     * @param val
     *            The value for the tuple.
     * 
     * @see #output(byte[], byte[])
     */
    public void output(byte[] val) {
    
        byte[] key = keyBuilder.append(uuid).append(tuples.size()).getKey();
        
        output(key,val);
        
    }
    
    /**
     * Map tasks MUST invoke this method to report key-value pairs. The data
     * will be buffered until the map task is complete.
     */
    public void output(byte[] key, byte[] val) {

        if (key == null)
            throw new IllegalArgumentException();

        if (val == null)
            throw new IllegalArgumentException();

        // Note: We have to fix up the sign when the hash code is negative!
        final int hashCode = hashFunction.hashCode(key);
        
        final int partition = (hashCode<0?-hashCode:hashCode) % nreduce;
        
        histogram[partition]++;
        
        tuples.add(new Tuple(partition,key,val));

    }

    /**
     * Return the histogram of the #of tuples in each output partition.
     */
    public int[] getHistogram() {

        return histogram;
        
    }
    
}